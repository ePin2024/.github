# ì—ì‡í•€ ê°œë°œ ê°€ì´ë“œ

## ğŸ“‹ ëª©ì°¨
- [ê°œìš”](#ê°œìš”)
- [ê°œë°œ í™˜ê²½ ì„¤ì •](#ê°œë°œ-í™˜ê²½-ì„¤ì •)
- [í”„ë¡œì íŠ¸ êµ¬ì¡°](#í”„ë¡œì íŠ¸-êµ¬ì¡°)
- [ê°œë°œ ì›Œí¬í”Œë¡œìš°](#ê°œë°œ-ì›Œí¬í”Œë¡œìš°)
- [ì½”ë”© ì»¨ë²¤ì…˜](#ì½”ë”©-ì»¨ë²¤ì…˜)
- [ë°±ì—”ë“œ ìƒì„¸ ì½”ë”© ê°€ì´ë“œ](#ë°±ì—”ë“œ-ìƒì„¸-ì½”ë”©-ê°€ì´ë“œ)
- [í”„ë¡ íŠ¸ì—”ë“œ ìƒì„¸ ì½”ë”© ê°€ì´ë“œ](#í”„ë¡ íŠ¸ì—”ë“œ-ìƒì„¸-ì½”ë”©-ê°€ì´ë“œ)
- [í…ŒìŠ¤íŠ¸ ê°€ì´ë“œë¼ì¸](#í…ŒìŠ¤íŠ¸-ê°€ì´ë“œë¼ì¸)
- [ë°°í¬ í”„ë¡œì„¸ìŠ¤](#ë°°í¬-í”„ë¡œì„¸ìŠ¤)
- [ë¬¸ì œ í•´ê²°](#ë¬¸ì œ-í•´ê²°)
- [ê¸°ì—¬ ë°©ë²•](#ê¸°ì—¬-ë°©ë²•)

## ê°œìš”

ì´ ë¬¸ì„œëŠ” ì‚¬ë‚´ ê°œë°œíŒ€ì„ ìœ„í•œ ê³µìš© ê°œë°œ ê°€ì´ë“œì…ë‹ˆë‹¤. ëª¨ë“  ê°œë°œìë“¤ì´ ì¼ê´€ëœ ë°©ì‹ìœ¼ë¡œ ê°œë°œí•  ìˆ˜ ìˆë„ë¡ ë•ê³ , íš¨ìœ¨ì ì¸ í˜‘ì—…ì„ ì§€ì›í•˜ê¸° ìœ„í•´ ì‘ì„±ë˜ì—ˆìŠµë‹ˆë‹¤.

### ì£¼ìš” ê¸°ìˆ  ìŠ¤íƒ
- **ì–¸ì–´**: Kotlin, JavaScript
- **í”„ë ˆì„ì›Œí¬**: Spring Boot, React.js
- **ë°ì´í„°ë² ì´ìŠ¤**: PostgreSQL, MySQL, MongoDB, Redis
- **ë„êµ¬**: IntelliJ IDEA, Cursor AI

## ê°œë°œ í™˜ê²½ ì„¤ì •

### ì‚¬ì „ ìš”êµ¬ì‚¬í•­
- **ë°±ì—”ë“œ ê°œë°œ**:
  - JDK 17 ì´ìƒ
  - IntelliJ IDEA
  - Gradle
- **í”„ë¡ íŠ¸ì—”ë“œ ê°œë°œ**:
  - Node.js (ë²„ì „ 18 ì´ìƒ)
  - npm ë˜ëŠ” yarn
- **ê³µí†µ**:
  - Git
  - Docker (ì„ íƒì‚¬í•­)

### ë¡œì»¬ ê°œë°œ í™˜ê²½ êµ¬ì„±

#### ë°±ì—”ë“œ (Spring Boot) ì„¤ì •
```bash
# ì €ì¥ì†Œ í´ë¡ 
git clone [í”„ë¡œì íŠ¸-ì €ì¥ì†Œ-URL]
cd [í”„ë¡œì íŠ¸ëª…]

# Gradle ë¹Œë“œ
./gradlew build

# ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰
./gradlew bootRun
```

#### í”„ë¡ íŠ¸ì—”ë“œ (React.js) ì„¤ì •
```bash
# í”„ë¡ íŠ¸ì—”ë“œ ë””ë ‰í† ë¦¬ë¡œ ì´ë™
cd frontend

# ì˜ì¡´ì„± ì„¤ì¹˜
npm install

# ê°œë°œ ì„œë²„ ì‹¤í–‰
npm start
```

### IDE ì„¤ì •
#### ë°±ì—”ë“œ ê°œë°œ (IntelliJ IDEA)
- **í•„ìˆ˜ í”ŒëŸ¬ê·¸ì¸**:
  - Kotlin
  - Spring Boot
  - Database Navigator
  - Git Toolbox

#### í”„ë¡ íŠ¸ì—”ë“œ ê°œë°œ (Cursor AI ë˜ëŠ” VSCode)
- **í•„ìˆ˜ í™•ì¥**:
  - ES7+ React/Redux/React-Native snippets
  - Prettier - Code formatter
  - ESLint
  - Auto Rename Tag

## í”„ë¡œì íŠ¸ êµ¬ì¡°

```
í”„ë¡œì íŠ¸ëª…/
â”œâ”€â”€ backend/                # ë°±ì—”ë“œ (Spring Boot - DDD êµ¬ì¡°)
â”‚   â”œâ”€â”€ src/main/kotlin/
â”‚   â”‚   â”œâ”€â”€ domain/        # ë„ë©”ì¸ ê³„ì¸µ
â”‚   â”‚   â”‚   â”œâ”€â”€ model/     # ë„ë©”ì¸ ëª¨ë¸ (Entity, Value Object)
â”‚   â”‚   â”‚   â”œâ”€â”€ service/   # ë„ë©”ì¸ ì„œë¹„ìŠ¤
â”‚   â”‚   â”‚   â””â”€â”€ repository/ # ë„ë©”ì¸ ë¦¬í¬ì§€í† ë¦¬ ì¸í„°í˜ì´ìŠ¤
â”‚   â”‚   â”œâ”€â”€ application/   # ì• í”Œë¦¬ì¼€ì´ì…˜ ê³„ì¸µ
â”‚   â”‚   â”‚   â”œâ”€â”€ service/   # ì• í”Œë¦¬ì¼€ì´ì…˜ ì„œë¹„ìŠ¤
â”‚   â”‚   â”‚   â”œâ”€â”€ usecase/   # ìœ ìŠ¤ì¼€ì´ìŠ¤
â”‚   â”‚   â”‚   â””â”€â”€ dto/       # ë°ì´í„° ì „ì†¡ ê°ì²´
â”‚   â”‚   â”œâ”€â”€ infrastructure/ # ì¸í”„ë¼ìŠ¤íŠ¸ëŸ­ì²˜ ê³„ì¸µ
â”‚   â”‚   â”‚   â”œâ”€â”€ persistence/ # ë°ì´í„°ë² ì´ìŠ¤ êµ¬í˜„
â”‚   â”‚   â”‚   â”œâ”€â”€ external/  # ì™¸ë¶€ ì‹œìŠ¤í…œ ì—°ë™
â”‚   â”‚   â”‚   â””â”€â”€ config/    # ì¸í”„ë¼ ì„¤ì •
â”‚   â”‚   â”œâ”€â”€ presentation/  # í”„ë ˆì  í…Œì´ì…˜ ê³„ì¸µ
â”‚   â”‚   â”‚   â”œâ”€â”€ controller/ # REST ì»¨íŠ¸ë¡¤ëŸ¬
â”‚   â”‚   â”‚   â””â”€â”€ dto/       # API ìš”ì²­/ì‘ë‹µ DTO
â”‚   â”‚   â””â”€â”€ shared/        # ê³µí†µ ê³„ì¸µ
â”‚   â”‚       â”œâ”€â”€ util/      # ìœ í‹¸ë¦¬í‹°
â”‚   â”‚       â””â”€â”€ exception/ # ì˜ˆì™¸ ì²˜ë¦¬
â”‚   â”œâ”€â”€ src/main/resources/ # ì„¤ì • íŒŒì¼
â”‚   â””â”€â”€ build.gradle.kts   # Gradle ì„¤ì •
â”œâ”€â”€ frontend/              # í”„ë¡ íŠ¸ì—”ë“œ (React.js)
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ components/    # ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ì»´í¬ë„ŒíŠ¸
â”‚   â”‚   â”œâ”€â”€ pages/         # í˜ì´ì§€ ì»´í¬ë„ŒíŠ¸
â”‚   â”‚   â”œâ”€â”€ hooks/         # ì»¤ìŠ¤í…€ í›…
â”‚   â”‚   â”œâ”€â”€ utils/         # ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
â”‚   â”‚   â””â”€â”€ styles/        # ìŠ¤íƒ€ì¼ íŒŒì¼
â”‚   â”œâ”€â”€ public/            # ì •ì  ìì‚°
â”‚   â””â”€â”€ package.json       # í”„ë¡œì íŠ¸ ì„¤ì •
â”œâ”€â”€ docs/                  # ë¬¸ì„œ
â””â”€â”€ README.md             # í”„ë¡œì íŠ¸ ê°œìš”
```

## ê°œë°œ ì›Œí¬í”Œë¡œìš°

### ë¸Œëœì¹˜ ì „ëµ
- `main`: í”„ë¡œë•ì…˜ ë¸Œëœì¹˜
- `develop`: ê°œë°œ ë¸Œëœì¹˜
- `feature/[ê¸°ëŠ¥ëª…]`: ê¸°ëŠ¥ ê°œë°œ ë¸Œëœì¹˜
- `bugfix/[ë²„ê·¸ëª…]`: ë²„ê·¸ ìˆ˜ì • ë¸Œëœì¹˜

### ê°œë°œ í”„ë¡œì„¸ìŠ¤

1. **ì´ìŠˆ ìƒì„±**: ì‘ì—…í•  ë‚´ìš©ì— ëŒ€í•œ ì´ìŠˆë¥¼ ìƒì„±í•©ë‹ˆë‹¤
2. **ë¸Œëœì¹˜ ìƒì„±**: ì ì ˆí•œ ë¸Œëœì¹˜ë¥¼ ìƒì„±í•©ë‹ˆë‹¤
   ```bash
   git checkout -b feature/ìƒˆë¡œìš´-ê¸°ëŠ¥
   ```
3. **ê°œë°œ**: ì½”ë“œë¥¼ ì‘ì„±í•˜ê³  í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤
4. **ì»¤ë°‹**: [ì»¤ë°‹ ë©”ì‹œì§€ ì»¨ë²¤ì…˜](#ì»¤ë°‹-ë©”ì‹œì§€-ì»¨ë²¤ì…˜)ì„ ë”°ë¼ ì»¤ë°‹í•©ë‹ˆë‹¤
5. **Pull Request**: ì½”ë“œ ë¦¬ë·°ë¥¼ ìœ„í•œ PRì„ ìƒì„±í•©ë‹ˆë‹¤

### ì»¤ë°‹ ë©”ì‹œì§€ ì»¨ë²¤ì…˜

```
íƒ€ì…(ë²”ìœ„): ê°„ë‹¨í•œ ì„¤ëª…

ìì„¸í•œ ì„¤ëª… (ì„ íƒì‚¬í•­)

Fixes #ì´ìŠˆë²ˆí˜¸
```

**íƒ€ì…**:
- `feat`: ìƒˆë¡œìš´ ê¸°ëŠ¥
- `fix`: ë²„ê·¸ ìˆ˜ì •
- `docs`: ë¬¸ì„œ ë³€ê²½
- `style`: ì½”ë“œ í¬ë§·íŒ…
- `refactor`: ë¦¬íŒ©í† ë§
- `test`: í…ŒìŠ¤íŠ¸ ì¶”ê°€/ìˆ˜ì •
- `chore`: ê¸°íƒ€ ë³€ê²½ì‚¬í•­

## ì½”ë”© ì»¨ë²¤ì…˜

### ë°±ì—”ë“œ ì½”ë”© ì»¨ë²¤ì…˜ (Kotlin)
- **ë“¤ì—¬ì“°ê¸°**: 4ì¹¸ ê³µë°± ì‚¬ìš© (Kotlin ê³µì‹ ì»¨ë²¤ì…˜)
- **ì„¸ë¯¸ì½œë¡ **: ìƒëµ ê¶Œì¥ (Kotlinì—ì„œëŠ” ì„ íƒì‚¬í•­)
- **ë³€ìˆ˜ëª…**: camelCase ì‚¬ìš©
- **ìƒìˆ˜**: UPPER_SNAKE_CASE ì‚¬ìš©
- **í´ë˜ìŠ¤ëª…**: PascalCase ì‚¬ìš©
- **íŒ¨í‚¤ì§€ëª…**: ì†Œë¬¸ì, ì ìœ¼ë¡œ êµ¬ë¶„
- **Boolean í•¨ìˆ˜**: `flag` ì ‘ë‘ì‚¬ ì‚¬ìš© (ì˜ˆ: `flagActive()`)

### í”„ë¡ íŠ¸ì—”ë“œ ì½”ë”© ì»¨ë²¤ì…˜ (JavaScript/React)
- **ë“¤ì—¬ì“°ê¸°**: 2ì¹¸ ê³µë°± ì‚¬ìš©
- **ì„¸ë¯¸ì½œë¡ **: ì‚¬ìš© ê¶Œì¥ (ESLint ì„¤ì •ì— ë”°ë¼)
- **ë³€ìˆ˜ëª…**: camelCase ì‚¬ìš©
- **ìƒìˆ˜**: UPPER_SNAKE_CASE ì‚¬ìš©
- **ì»´í¬ë„ŒíŠ¸ëª…**: PascalCase ì‚¬ìš©
- **íŒŒì¼ëª…**: PascalCase (ì»´í¬ë„ŒíŠ¸), camelCase (ìœ í‹¸ë¦¬í‹°)
- **í´ë”ëª…**: kebab-case ì‚¬ìš©

### ê³µí†µ ëª…ëª… ê·œì¹™
- **ì»´í¬ë„ŒíŠ¸ íŒŒì¼**: PascalCase (ì˜ˆ: `UserProfile.jsx`)
- **ìœ í‹¸ë¦¬í‹° íŒŒì¼**: camelCase (ì˜ˆ: `dateUtils.js`)
- **í´ë”ëª…**: kebab-case (ì˜ˆ: `user-management`)
- **API ì—”ë“œí¬ì¸íŠ¸**: kebab-case (ì˜ˆ: `/api/v1/user-profiles`)

### ì½”ë“œ ìŠ¤íƒ€ì¼ ë„êµ¬
#### ë°±ì—”ë“œ (Kotlin)
- **Linter**: ktlint
- **ì½”ë“œ í¬ë§·íŒ…**: `./gradlew ktlintFormat`
- **ë¦°íŠ¸ ì²´í¬**: `./gradlew ktlintCheck`

#### í”„ë¡ íŠ¸ì—”ë“œ (JavaScript/React)
- **Linter**: ESLint + Prettier
- **ì½”ë“œ í¬ë§·íŒ…**: `npm run format`
- **ë¦°íŠ¸ ì²´í¬**: `npm run lint`

## ë°±ì—”ë“œ ìƒì„¸ ì½”ë”© ê°€ì´ë“œ

### Kotlin ì½”ë”© ìŠ¤íƒ€ì¼

#### ëª…ëª… ê·œì¹™
```kotlin
// í´ë˜ìŠ¤: PascalCase
class UserService
class OrderRepository

// í•¨ìˆ˜/ë³€ìˆ˜: camelCase
fun getUserById(id: Long): User?
val userName = "john_doe"

// ìƒìˆ˜: UPPER_SNAKE_CASE
const val MAX_RETRY_COUNT = 3
const val DEFAULT_PAGE_SIZE = 20

// íŒ¨í‚¤ì§€: ì†Œë¬¸ì, ì ìœ¼ë¡œ êµ¬ë¶„
package com.company.user.domain.model
```

#### í•¨ìˆ˜ ì‘ì„± ê°€ì´ë“œ
```kotlin
// âœ… ì¢‹ì€ ì˜ˆ: ëª…í™•í•œ í•¨ìˆ˜ëª…ê³¼ íƒ€ì… ì§€ì •
fun findUserByEmail(email: String): User? {
    return userRepository.findByEmail(email)
}

// âœ… í•¨ìˆ˜ ì¸ìê°€ ë§ì„ ë•ŒëŠ” ì—¬ëŸ¬ ì¤„ë¡œ
fun createUser(
    name: String,
    email: String,
    phoneNumber: String,
    address: String
): User {
    // êµ¬í˜„
}

// âœ… í™•ì¥ í•¨ìˆ˜ í™œìš©
fun String.validEmailFlag(): Boolean {
    return this.contains("@") && this.contains(".")
}
```

#### Null Safety í™œìš©
```kotlin
// âœ… Safe Call ì—°ì‚°ì ì‚¬ìš©
val userName = user?.name ?: "Unknown"

// âœ… let í•¨ìˆ˜ í™œìš©
user?.let { 
    sendNotification(it.email)
    logUserActivity(it.id)
}

// âœ… ì¡°ê±´ë¶€ ì‹¤í–‰
if (user != null) {
    processUser(user)
}
```

### DDD êµ¬í˜„ ê°€ì´ë“œ

#### Entity ì„¤ê³„ ì£¼ìš” ì›ì¹™

**val vs var ì„ íƒ**:
- **var**: ë³€ê²½ ê°€ëŠ¥í•œ ì†ì„± (ëŒ€ë¶€ë¶„ì˜ Entity í•„ë“œ)
- **val**: ë¶ˆë³€ ì†ì„± (ID, createdAt ë“± ìƒì„± í›„ ë³€ê²½ë˜ì§€ ì•ŠëŠ” í•„ë“œ)

**data class vs class**:
- **class ê¶Œì¥**: EntityëŠ” ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ í¬í•¨í•˜ë¯€ë¡œ ì¼ë°˜ class ì‚¬ìš©
- **data class ì§€ì–‘**: equals/hashCodeê°€ ëª¨ë“  í•„ë“œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ìƒì„±ë˜ì–´ ë¬¸ì œ ë°œìƒ ê°€ëŠ¥

**JPA ê¸°ë³¸ ìƒì„±ì**:
- JPAëŠ” ë¦¬í”Œë ‰ì…˜ì„ í†µí•´ ê¸°ë³¸ ìƒì„±ìë¡œ ê°ì²´ë¥¼ ìƒì„±
- Kotlinì—ì„œëŠ” ëª…ì‹œì ìœ¼ë¡œ ê¸°ë³¸ ìƒì„±ì ì œê³µ í•„ìš”

#### 1. Domain Model (ì—”í‹°í‹°/ê°’ ê°ì²´)
```kotlin
// Entity ì˜ˆì œ
@Entity
@Table(name = "users")
class User(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    var id: Long = 0,
    
    @Column(nullable = false)
    var name: String,
    
    @Column(nullable = false, unique = true)
    var email: Email,
    
    @Enumerated(EnumType.STRING)
    var status: UserStatus = UserStatus.ACTIVE,
    
    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    val createdAt: LocalDateTime = LocalDateTime.now(),
    
    @UpdateTimestamp
    @Column(name = "updated_at", nullable = false)
    var updatedAt: LocalDateTime = LocalDateTime.now()
) {
    // JPA ê¸°ë³¸ ìƒì„±ì
    constructor() : this(0, "", Email(""), UserStatus.ACTIVE)
    
    fun activate() {
        status = UserStatus.ACTIVE
        updatedAt = LocalDateTime.now()
    }
    
    fun deactivate() {
        status = UserStatus.INACTIVE
        updatedAt = LocalDateTime.now()
    }
    
    fun updateName(newName: String) {
        require(newName.isNotBlank()) { "Name cannot be blank" }
        name = newName
        updatedAt = LocalDateTime.now()
    }
    
    fun flagActive(): Boolean = status == UserStatus.ACTIVE
    
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is User) return false
        return id == other.id
    }
    
    override fun hashCode(): Int = id.hashCode()
    
    override fun toString(): String = "User(id=$id, name='$name', email=$email, status=$status)"
}

// Value Object ì˜ˆì œ
@Embeddable
data class Email(
    @Column(name = "email")
    private val value: String
) {
    init {
        require(validFlag(value)) { "Invalid email format: $value" }
    }
    
    private fun validFlag(email: String): Boolean {
        return email.matches(Regex("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$"))
    }
    
    override fun toString(): String = value
}

enum class UserStatus {
    ACTIVE, INACTIVE, SUSPENDED
}
```

#### 2. Domain Service
```kotlin
@Component
class UserDomainService(
    private val userRepository: UserRepository,
    private val emailValidator: EmailValidator
) {
    
    fun validateUserRegistration(user: User): ValidationResult {
        val errors = mutableListOf<String>()
        
        // ì´ë©”ì¼ ì¤‘ë³µ ì²´í¬
        if (userRepository.existsByEmail(user.email)) {
            errors.add("Email already exists")
        }
        
        // ë„ë©”ì¸ ê·œì¹™ ê²€ì¦
        if (!emailValidator.validFlag(user.email.toString())) {
            errors.add("Invalid email format")
        }
        
        return if (errors.isEmpty()) {
            ValidationResult.success()
        } else {
            ValidationResult.failure(errors)
        }
    }
}
```

#### 3. Repository Interface (Domain)
```kotlin
interface UserRepository {
    fun save(user: User): User
    fun findById(id: Long): User?
    fun findByEmail(email: Email): User?
    fun existsByEmail(email: Email): Boolean
    fun findAll(pageable: Pageable): Page<User>
    fun delete(user: User)
}
```

#### 4. Repository Implementation (Infrastructure)
```kotlin
@Repository
class JpaUserRepository(
    private val jpaRepository: UserJpaRepository
) : UserRepository {
    
    override fun save(user: User): User {
        return jpaRepository.save(user)
    }
    
    override fun findById(id: Long): User? {
        return jpaRepository.findById(id).orElse(null)
    }
    
    override fun findByEmail(email: Email): User? {
        return jpaRepository.findByEmail(email.toString())
    }
    
    override fun existsByEmail(email: Email): Boolean {
        return jpaRepository.existsByEmail(email.toString())
    }
    
    override fun findAll(pageable: Pageable): Page<User> {
        return jpaRepository.findAll(pageable)
    }
    
    override fun delete(user: User) {
        jpaRepository.delete(user)
    }
}

@Repository
interface UserJpaRepository : JpaRepository<User, Long> {
    fun findByEmail(email: String): User?
    fun existsByEmail(email: String): Boolean
}
```

#### 5. Application Service
```kotlin
@Service
@Transactional(readOnly = true)
class UserApplicationService(
    private val userRepository: UserRepository,
    private val userDomainService: UserDomainService,
    private val eventPublisher: ApplicationEventPublisher
) {
    
    @Transactional
    fun createUser(command: CreateUserCommand): UserResponse {
        val user = User(
            name = command.name,
            email = Email(command.email)
        )
        
        // ë„ë©”ì¸ ê²€ì¦
        val validationResult = userDomainService.validateUserRegistration(user)
        if (!validationResult.successFlag) {
            throw ValidationException(validationResult.errors)
        }
        
        // ì €ì¥
        val savedUser = userRepository.save(user)
        
        // ì´ë²¤íŠ¸ ë°œí–‰
        eventPublisher.publishEvent(UserCreatedEvent(savedUser.id, savedUser.email))
        
        return UserResponse.from(savedUser)
    }
    
    fun getUserById(id: Long): UserResponse {
        val user = userRepository.findById(id)
            ?: throw EntityNotFoundException("User not found with id: $id")
        
        return UserResponse.from(user)
    }
    
    fun getUsersByPage(page: Int, size: Int): Page<UserResponse> {
        val pageable = PageRequest.of(page, size, Sort.by("createdAt").descending())
        return userRepository.findAll(pageable).map { UserResponse.from(it) }
    }
}
```

#### 6. DTO ë° Command/Query ê°ì²´
```kotlin
// Command ê°ì²´
data class CreateUserCommand(
    val name: String,
    val email: String
) {
    init {
        require(name.isNotBlank()) { "Name cannot be blank" }
        require(email.isNotBlank()) { "Email cannot be blank" }
    }
}

// Response DTO
data class UserResponse(
    val id: Long,
    val name: String,
    val email: String,
    val status: String,
    val createdAt: LocalDateTime
) {
    companion object {
        fun from(user: User): UserResponse {
            return UserResponse(
                id = user.id,
                name = user.name,
                email = user.email.toString(),
                status = user.status.name,
                createdAt = user.createdAt
            )
        }
    }
}
```

### Redis ì„¤ì • ë° ì‚¬ìš© ê°€ì´ë“œ

#### 1. Redis ì„¤ì •

**application.yml ì„¤ì •**
```yaml
spring:
  redis:
    host: ${REDIS_HOST:localhost}
    port: ${REDIS_PORT:6379}
    password: ${REDIS_PASSWORD:}
    timeout: 2000ms
    lettuce:
      pool:
        max-active: 8
        max-idle: 8
        min-idle: 0
        max-wait: -1ms
    database: 0  # ê¸°ë³¸ ë°ì´í„°ë² ì´ìŠ¤ ì¸ë±ìŠ¤
```

**RedisConfig ì„¤ì • í´ë˜ìŠ¤**
```kotlin
@Configuration
@EnableRedisRepositories
class RedisConfig {
    
    @Value("\${spring.redis.host}")
    private lateinit var host: String
    
    @Value("\${spring.redis.port}")
    private var port: Int = 6379
    
    @Value("\${spring.redis.password}")
    private lateinit var password: String
    
    @Bean
    fun redisConnectionFactory(): LettuceConnectionFactory {
        val configuration = RedisStandaloneConfiguration(host, port)
        if (password.isNotBlank()) {
            configuration.password = RedisPassword.of(password)
        }
        return LettuceConnectionFactory(configuration)
    }
    
    @Bean
    fun redisTemplate(): RedisTemplate<String, Any> {
        val template = RedisTemplate<String, Any>()
        template.connectionFactory = redisConnectionFactory()
        
        // JSON ì§ë ¬í™” ì„¤ì •
        val jackson2JsonRedisSerializer = Jackson2JsonRedisSerializer(Any::class.java)
        val objectMapper = ObjectMapper()
        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY)
        objectMapper.activateDefaultTyping(
            LaissezFaireSubTypeValidator.instance,
            ObjectMapper.DefaultTyping.NON_FINAL
        )
        jackson2JsonRedisSerializer.setObjectMapper(objectMapper)
        
        // Key-Value ì§ë ¬í™” ì„¤ì •
        template.keySerializer = StringRedisSerializer()
        template.valueSerializer = jackson2JsonRedisSerializer
        template.hashKeySerializer = StringRedisSerializer()
        template.hashValueSerializer = jackson2JsonRedisSerializer
        
        template.afterPropertiesSet()
        return template
    }
    
    @Bean
    fun stringRedisTemplate(): StringRedisTemplate {
        return StringRedisTemplate(redisConnectionFactory())
    }
}
```

#### 2. Redis ì‚¬ìš© íŒ¨í„´

**ìºì‹œ ì„œë¹„ìŠ¤ êµ¬í˜„**
```kotlin
@Service
class RedisCacheService(
    private val redisTemplate: RedisTemplate<String, Any>,
    private val stringRedisTemplate: StringRedisTemplate
) {
    
    companion object {
        private const val USER_CACHE_PREFIX = "user:"
        private const val SESSION_PREFIX = "session:"
        private const val CACHE_TTL = 3600L // 1ì‹œê°„
    }
    
    // ê°ì²´ ìºì‹œ ì €ì¥
    fun cacheUser(userId: Long, user: User, ttlSeconds: Long = CACHE_TTL) {
        val key = "$USER_CACHE_PREFIX$userId"
        redisTemplate.opsForValue().set(key, user, Duration.ofSeconds(ttlSeconds))
    }
    
    // ê°ì²´ ìºì‹œ ì¡°íšŒ
    fun getCachedUser(userId: Long): User? {
        val key = "$USER_CACHE_PREFIX$userId"
        return redisTemplate.opsForValue().get(key) as? User
    }
    
    // ìºì‹œ ì‚­ì œ
    fun evictUserCache(userId: Long) {
        val key = "$USER_CACHE_PREFIX$userId"
        redisTemplate.delete(key)
    }
    
    // íŒ¨í„´ ê¸°ë°˜ ìºì‹œ ì‚­ì œ
    fun evictUserCacheByPattern(pattern: String = "$USER_CACHE_PREFIX*") {
        val keys = redisTemplate.keys(pattern)
        if (keys.isNotEmpty()) {
            redisTemplate.delete(keys)
        }
    }
    
    // ì„¸ì…˜ ê´€ë¦¬
    fun createSession(sessionId: String, userId: Long, ttlSeconds: Long = 1800L) {
        val key = "$SESSION_PREFIX$sessionId"
        val sessionData = mapOf(
            "userId" to userId,
            "createdAt" to System.currentTimeMillis(),
            "lastAccessTime" to System.currentTimeMillis()
        )
        redisTemplate.opsForHash<String, Any>().putAll(key, sessionData)
        redisTemplate.expire(key, Duration.ofSeconds(ttlSeconds))
    }
    
    // ì„¸ì…˜ ì¡°íšŒ
    fun getSession(sessionId: String): Map<String, Any>? {
        val key = "$SESSION_PREFIX$sessionId"
        val sessionData = redisTemplate.opsForHash<String, Any>().entries(key)
        
        return if (sessionData.isNotEmpty()) {
            // ë§ˆì§€ë§‰ ì ‘ê·¼ ì‹œê°„ ì—…ë°ì´íŠ¸
            redisTemplate.opsForHash<String, Any>().put(key, "lastAccessTime", System.currentTimeMillis())
            sessionData
        } else {
            null
        }
    }
    
    // ì¹´ìš´í„° ì¦ê°€ (ì¡°íšŒìˆ˜, ì¢‹ì•„ìš” ë“±)
    fun incrementCounter(key: String): Long {
        return stringRedisTemplate.opsForValue().increment(key) ?: 0L
    }
    
    // ì¹´ìš´í„° ê°’ ì¡°íšŒ
    fun getCounter(key: String): Long {
        return stringRedisTemplate.opsForValue().get(key)?.toLongOrNull() ?: 0L
    }
    
    // Rate Limiting
    fun flagRateLimited(key: String, limit: Int, windowSeconds: Long): Boolean {
        val count = stringRedisTemplate.opsForValue().increment(key) ?: 0L
        
        if (count == 1L) {
            stringRedisTemplate.expire(key, Duration.ofSeconds(windowSeconds))
        }
        
        return count > limit
    }
}
```

**ì• í”Œë¦¬ì¼€ì´ì…˜ ì„œë¹„ìŠ¤ì—ì„œ ìºì‹œ í™œìš©**
```kotlin
@Service
@Transactional(readOnly = true)
class UserApplicationService(
    private val userRepository: UserRepository,
    private val redisCacheService: RedisCacheService
) {
    
    fun getUserById(id: Long): UserResponse {
        // 1. ìºì‹œì—ì„œ ë¨¼ì € ì¡°íšŒ
        redisCacheService.getCachedUser(id)?.let { cachedUser ->
            return UserResponse.from(cachedUser)
        }
        
        // 2. ìºì‹œì— ì—†ìœ¼ë©´ ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì¡°íšŒ
        val user = userRepository.findById(id)
            ?: throw EntityNotFoundException("User not found with id: $id")
        
        // 3. ì¡°íšŒí•œ ë°ì´í„°ë¥¼ ìºì‹œì— ì €ì¥
        redisCacheService.cacheUser(id, user)
        
        return UserResponse.from(user)
    }
    
    @Transactional
    fun updateUser(id: Long, request: UpdateUserRequest): UserResponse {
        val user = userRepository.findById(id)
            ?: throw EntityNotFoundException("User not found with id: $id")
        
        user.updateName(request.name)
        val updatedUser = userRepository.save(user)
        
        // ìºì‹œ ì—…ë°ì´íŠ¸
        redisCacheService.cacheUser(id, updatedUser)
        
        return UserResponse.from(updatedUser)
    }
    
    @Transactional
    fun deleteUser(id: Long) {
        userRepository.findById(id)?.let { user ->
            userRepository.delete(user)
            // ìºì‹œì—ì„œ ì‚­ì œ
            redisCacheService.evictUserCache(id)
        }
    }
}
```

#### 3. Spring Cache ì–´ë…¸í…Œì´ì…˜ í™œìš©

**CacheConfig ì„¤ì •**
```kotlin
@Configuration
@EnableCaching
class CacheConfig {
    
    @Bean
    fun cacheManager(): CacheManager {
        val redisCacheManager = RedisCacheManager.Builder(redisConnectionFactory())
            .cacheDefaults(
                RedisCacheConfiguration.defaultCacheConfig()
                    .entryTtl(Duration.ofHours(1))
                    .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(StringRedisSerializer()))
                    .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(Jackson2JsonRedisSerializer(Any::class.java)))
            )
            .build()
        
        return redisCacheManager
    }
}
```

**ì–´ë…¸í…Œì´ì…˜ ê¸°ë°˜ ìºì‹±**
```kotlin
@Service
class UserService(
    private val userRepository: UserRepository
) {
    
    @Cacheable(value = ["users"], key = "#id")
    fun getUserById(id: Long): User? {
        return userRepository.findById(id)
    }
    
    @Cacheable(value = ["users"], key = "#email.value")
    fun getUserByEmail(email: Email): User? {
        return userRepository.findByEmail(email)
    }
    
    @CacheEvict(value = ["users"], key = "#id")
    fun evictUserCache(id: Long) {
        // ìºì‹œë§Œ ì‚­ì œ
    }
    
    @CacheEvict(value = ["users"], allEntries = true)
    fun evictAllUserCache() {
        // ëª¨ë“  ì‚¬ìš©ì ìºì‹œ ì‚­ì œ
    }
    
    @CachePut(value = ["users"], key = "#result.id")
    fun updateUser(id: Long, request: UpdateUserRequest): User {
        val user = userRepository.findById(id)
            ?: throw EntityNotFoundException("User not found")
        
        user.updateName(request.name)
        return userRepository.save(user)
    }
}
```

#### 4. ê³ ê¸‰ Redis ì‚¬ìš© íŒ¨í„´

**ë¶„ì‚° ë½ êµ¬í˜„**
```kotlin
@Component
class RedisDistributedLock(
    private val stringRedisTemplate: StringRedisTemplate
) {
    
    fun acquireLock(lockKey: String, lockValue: String, expireTime: Long): Boolean {
        return stringRedisTemplate.opsForValue()
            .setIfAbsent(lockKey, lockValue, Duration.ofSeconds(expireTime)) ?: false
    }
    
    fun releaseLock(lockKey: String, lockValue: String): Boolean {
        val script = """
            if redis.call('get', KEYS[1]) == ARGV[1] then
                return redis.call('del', KEYS[1])
            else
                return 0
            end
        """.trimIndent()
        
        val result = stringRedisTemplate.execute(
            RedisScript.of(script, Long::class.java),
            listOf(lockKey),
            lockValue
        )
        
        return result == 1L
    }
}

// ì‚¬ìš© ì˜ˆì‹œ
@Service
class OrderService(
    private val distributedLock: RedisDistributedLock
) {
    
    fun processOrder(orderId: Long) {
        val lockKey = "order:lock:$orderId"
        val lockValue = UUID.randomUUID().toString()
        
        if (distributedLock.acquireLock(lockKey, lockValue, 30)) {
            try {
                // ì£¼ë¬¸ ì²˜ë¦¬ ë¡œì§
                processOrderInternal(orderId)
            } finally {
                distributedLock.releaseLock(lockKey, lockValue)
            }
        } else {
            throw IllegalStateException("Could not acquire lock for order: $orderId")
        }
    }
}
```

**Pub/Sub ë©”ì‹œì§•**
```kotlin
@Component
class RedisMessagePublisher(
    private val redisTemplate: RedisTemplate<String, Any>
) {
    
    fun publishMessage(channel: String, message: Any) {
        redisTemplate.convertAndSend(channel, message)
    }
}

@Component
class RedisMessageSubscriber : MessageListener {
    
    override fun onMessage(message: Message, pattern: ByteArray?) {
        val messageBody = String(message.body)
        val channel = String(message.channel)
        
        // ë©”ì‹œì§€ ì²˜ë¦¬ ë¡œì§
        processMessage(channel, messageBody)
    }
    
    private fun processMessage(channel: String, message: String) {
        when (channel) {
            "user.created" -> handleUserCreated(message)
            "user.updated" -> handleUserUpdated(message)
            else -> println("Unknown channel: $channel")
        }
    }
}

@Configuration
class RedisMessageConfig {
    
    @Bean
    fun redisMessageListenerContainer(
        connectionFactory: RedisConnectionFactory,
        messageSubscriber: RedisMessageSubscriber
    ): RedisMessageListenerContainer {
        val container = RedisMessageListenerContainer()
        container.setConnectionFactory(connectionFactory)
        container.addMessageListener(messageSubscriber, PatternTopic("user.*"))
        return container
    }
}
```

#### 5. ì„±ëŠ¥ ìµœì í™” ë° ëª¨ë‹ˆí„°ë§

**Redis ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§**
```kotlin
@Component
class RedisHealthIndicator(
    private val redisTemplate: RedisTemplate<String, Any>
) : HealthIndicator {
    
    override fun health(): Health {
        return try {
            val connection = redisTemplate.connectionFactory?.connection
            val info = connection?.info() ?: emptyMap()
            
            Health.up()
                .withDetail("redis", "Available")
                .withDetail("version", info["redis_version"])
                .withDetail("used_memory", info["used_memory_human"])
                .build()
        } catch (e: Exception) {
            Health.down()
                .withDetail("redis", "Not Available")
                .withException(e)
                .build()
        }
    }
}
```

**Redis ì—°ê²° í’€ ìµœì í™”**
```yaml
spring:
  redis:
    lettuce:
      pool:
        max-active: 16        # ìµœëŒ€ í™œì„± ì—°ê²° ìˆ˜
        max-idle: 8           # ìµœëŒ€ ìœ íœ´ ì—°ê²° ìˆ˜  
        min-idle: 2           # ìµœì†Œ ìœ íœ´ ì—°ê²° ìˆ˜
        max-wait: 1000ms      # ì—°ê²° ëŒ€ê¸° ì‹œê°„
      shutdown-timeout: 100ms # ì¢…ë£Œ ëŒ€ê¸° ì‹œê°„
    timeout: 3000ms          # ëª…ë ¹ ì‹¤í–‰ íƒ€ì„ì•„ì›ƒ
```

#### 6. Redis ê°œë°œ/ìš´ì˜ íŒ

**ê°œë°œ í™˜ê²½ì—ì„œ Redis ì‚¬ìš©**
```bash
# Dockerë¡œ Redis ì‹¤í–‰
docker run -d --name redis -p 6379:6379 redis:7-alpine

# Redis CLI ì ‘ì†
docker exec -it redis redis-cli

# ê¸°ë³¸ ëª…ë ¹ì–´
redis-cli ping
redis-cli keys "*"
redis-cli flushall  # ëª¨ë“  ë°ì´í„° ì‚­ì œ (ê°œë°œìš©)
```

**ì„±ëŠ¥ ê³ ë ¤ì‚¬í•­**
- **í‚¤ ì„¤ê³„**: ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ì‚¬ìš© (`user:123`, `session:abc`)
- **ë§Œë£Œ ì‹œê°„**: ëª¨ë“  ìºì‹œì— ì ì ˆí•œ TTL ì„¤ì •
- **ë©”ëª¨ë¦¬ ê´€ë¦¬**: maxmemory ì •ì±… ì„¤ì • (allkeys-lru ê¶Œì¥)
- **íŒŒì´í”„ë¼ì´ë‹**: ì—¬ëŸ¬ ëª…ë ¹ì–´ë¥¼ í•œ ë²ˆì— ì‹¤í–‰í•˜ì—¬ ë„¤íŠ¸ì›Œí¬ ì™•ë³µ ìµœì†Œí™”

**ë³´ì•ˆ ê³ ë ¤ì‚¬í•­**
- Redis íŒ¨ìŠ¤ì›Œë“œ ì„¤ì •
- ë°©í™”ë²½ìœ¼ë¡œ í¬íŠ¸ ì œí•œ
- Redis Sentinel ë˜ëŠ” Cluster ì‚¬ìš© (ê³ ê°€ìš©ì„±)

### MongoDB ì„¤ì • ë° ì‚¬ìš© ê°€ì´ë“œ

#### 1. MongoDB ì„¤ì •

**build.gradle.kts ì˜ì¡´ì„± ì¶”ê°€**
```kotlin
dependencies {
    implementation("org.springframework.boot:spring-boot-starter-data-mongodb")
    implementation("org.springframework.boot:spring-boot-starter-data-mongodb-reactive") // ë°˜ì‘í˜• ì‚¬ìš© ì‹œ
}
```

**application.yml ì„¤ì •**
```yaml
spring:
  data:
    mongodb:
      uri: ${MONGODB_URI:mongodb://localhost:27017/appdb}
      # ë˜ëŠ” ê°œë³„ ì„¤ì •
      host: ${MONGODB_HOST:localhost}
      port: ${MONGODB_PORT:27017}
      database: ${MONGODB_DATABASE:appdb}
      username: ${MONGODB_USERNAME:}
      password: ${MONGODB_PASSWORD:}
      authentication-database: admin
      
  # MongoDB ë¡œê¹… ì„¤ì •
logging:
  level:
    org.springframework.data.mongodb: DEBUG
    org.mongodb.driver: INFO
```

**MongoDB ì„¤ì • í´ë˜ìŠ¤**
```kotlin
@Configuration
@EnableMongoRepositories
class MongoConfig {
    
    @Value("\${spring.data.mongodb.uri}")
    private lateinit var mongoUri: String
    
    @Bean
    fun mongoClient(): MongoClient {
        val connectionString = ConnectionString(mongoUri)
        val settings = MongoClientSettings.builder()
            .applyConnectionString(connectionString)
            .codecRegistry(
                CodecRegistries.fromRegistries(
                    MongoClientSettings.getDefaultCodecRegistry(),
                    CodecRegistries.fromProviders(PojoCodecProvider.builder().automatic(true).build())
                )
            )
            .build()
        
        return MongoClients.create(settings)
    }
    
    @Bean
    fun mongoTemplate(mongoClient: MongoClient): MongoTemplate {
        return MongoTemplate(mongoClient, "appdb")
    }
    
    // íŠ¸ëœì­ì…˜ ë§¤ë‹ˆì € ì„¤ì • (MongoDB 4.0+ ë³µì œë³¸ ì„¸íŠ¸ì—ì„œë§Œ ì§€ì›)
    @Bean
    fun mongoTransactionManager(mongoDbFactory: MongoDatabaseFactory): MongoTransactionManager {
        return MongoTransactionManager(mongoDbFactory)
    }
}
```

#### 2. Document ëª¨ë¸ë§

**ê¸°ë³¸ Document ì—”í‹°í‹°**
```kotlin
@Document(collection = "users")
data class UserDocument(
    @Id
    @Field("_id")
    val id: String? = null,
    
    @Field("name")
    val name: String,
    
    @Field("email")
    val email: String,
    
    @Field("age")
    val age: Int? = null,
    
    @Field("status")
    val status: UserStatus = UserStatus.ACTIVE,
    
    @Field("profile")
    val profile: UserProfile? = null,
    
    @Field("tags")
    val tags: List<String> = emptyList(),
    
    @Field("metadata")
    val metadata: Map<String, Any> = emptyMap(),
    
    @Field("created_at")
    val createdAt: LocalDateTime = LocalDateTime.now(),
    
    @Field("updated_at")
    val updatedAt: LocalDateTime = LocalDateTime.now()
) {
    // ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ë©”ì„œë“œ
    fun flagActive(): Boolean = status == UserStatus.ACTIVE
    
    fun hasTag(tag: String): Boolean = tags.contains(tag)
    
    fun addTag(tag: String): UserDocument {
        return copy(tags = tags + tag, updatedAt = LocalDateTime.now())
    }
    
    fun updateProfile(newProfile: UserProfile): UserDocument {
        return copy(profile = newProfile, updatedAt = LocalDateTime.now())
    }
}

// ì„ë² ë””ë“œ ë„íë¨¼íŠ¸
data class UserProfile(
    @Field("avatar_url")
    val avatarUrl: String? = null,
    
    @Field("bio")
    val bio: String? = null,
    
    @Field("social_links")
    val socialLinks: Map<String, String> = emptyMap(),
    
    @Field("preferences")
    val preferences: UserPreferences = UserPreferences()
)

data class UserPreferences(
    @Field("theme")
    val theme: String = "light",
    
    @Field("language")
    val language: String = "ko",
    
    @Field("notifications")
    val notifications: NotificationSettings = NotificationSettings()
)

data class NotificationSettings(
    @Field("email_enabled")
    val emailEnabled: Boolean = true,
    
    @Field("push_enabled")
    val pushEnabled: Boolean = true,
    
    @Field("marketing_enabled")
    val marketingEnabled: Boolean = false
)

enum class UserStatus {
    ACTIVE, INACTIVE, SUSPENDED, DELETED
}
```

**ë³µì¡í•œ Document ì˜ˆì œ (ë¸”ë¡œê·¸ í¬ìŠ¤íŠ¸)**
```kotlin
@Document(collection = "posts")
data class PostDocument(
    @Id
    val id: String? = null,
    
    @Field("title")
    val title: String,
    
    @Field("content")
    val content: String,
    
    @Field("author_id")
    val authorId: String,
    
    @Field("author_name")
    val authorName: String,
    
    @Field("category")
    val category: String,
    
    @Field("tags")
    val tags: List<String> = emptyList(),
    
    @Field("comments")
    val comments: List<Comment> = emptyList(),
    
    @Field("meta")
    val meta: PostMeta = PostMeta(),
    
    @Field("published")
    val published: Boolean = false,
    
    @Field("published_at")
    val publishedAt: LocalDateTime? = null,
    
    @Field("created_at")
    val createdAt: LocalDateTime = LocalDateTime.now(),
    
    @Field("updated_at")
    val updatedAt: LocalDateTime = LocalDateTime.now()
) {
    fun addComment(comment: Comment): PostDocument {
        return copy(
            comments = comments + comment,
            meta = meta.copy(commentCount = comments.size + 1),
            updatedAt = LocalDateTime.now()
        )
    }
    
    fun publish(): PostDocument {
        return copy(
            published = true,
            publishedAt = LocalDateTime.now(),
            updatedAt = LocalDateTime.now()
        )
    }
}

data class Comment(
    @Field("id")
    val id: String = ObjectId().toString(),
    
    @Field("author_id")
    val authorId: String,
    
    @Field("author_name")
    val authorName: String,
    
    @Field("content")
    val content: String,
    
    @Field("created_at")
    val createdAt: LocalDateTime = LocalDateTime.now()
)

data class PostMeta(
    @Field("view_count")
    val viewCount: Long = 0,
    
    @Field("like_count")
    val likeCount: Long = 0,
    
    @Field("comment_count")
    val commentCount: Long = 0,
    
    @Field("reading_time")
    val readingTime: Int = 0 // ë¶„ ë‹¨ìœ„
)
```

#### 3. Repository íŒ¨í„´

**ê¸°ë³¸ Repository ì¸í„°í˜ì´ìŠ¤**
```kotlin
interface UserRepository : MongoRepository<UserDocument, String> {
    
    // ë©”ì„œë“œ ì´ë¦„ ê¸°ë°˜ ì¿¼ë¦¬
    fun findByEmail(email: String): UserDocument?
    fun findByNameContainingIgnoreCase(name: String): List<UserDocument>
    fun findByStatus(status: UserStatus): List<UserDocument>
    fun findByTagsContaining(tag: String): List<UserDocument>
    fun findByCreatedAtBetween(start: LocalDateTime, end: LocalDateTime): List<UserDocument>
    
    // í˜ì´ì§• ì§€ì›
    fun findByStatus(status: UserStatus, pageable: Pageable): Page<UserDocument>
    
    // ë³µí•© ì¡°ê±´
    fun findByStatusAndCreatedAtAfter(status: UserStatus, createdAt: LocalDateTime): List<UserDocument>
    
    // ì¡´ì¬ ì—¬ë¶€ í™•ì¸
    fun existsByEmail(email: String): Boolean
    
    // ì¹´ìš´íŠ¸
    fun countByStatus(status: UserStatus): Long
    
    // ì •ë ¬
    fun findByStatusOrderByCreatedAtDesc(status: UserStatus): List<UserDocument>
}
```

**ì»¤ìŠ¤í…€ Repository êµ¬í˜„**
```kotlin
interface UserRepositoryCustom {
    fun findUsersByComplexCriteria(criteria: UserSearchCriteria): List<UserDocument>
    fun findUsersWithAggregation(): List<UserStatsDto>
    fun updateUserTags(userId: String, tags: List<String>): UpdateResult
}

@Repository
class UserRepositoryCustomImpl(
    private val mongoTemplate: MongoTemplate
) : UserRepositoryCustom {
    
    override fun findUsersByComplexCriteria(criteria: UserSearchCriteria): List<UserDocument> {
        val query = Query()
        
        // ë™ì  ì¿¼ë¦¬ êµ¬ì„±
        criteria.name?.let { 
            query.addCriteria(Criteria.where("name").regex(".*$it.*", "i"))
        }
        
        criteria.email?.let {
            query.addCriteria(Criteria.where("email").`is`(it))
        }
        
        criteria.status?.let {
            query.addCriteria(Criteria.where("status").`is`(it))
        }
        
        criteria.tags?.let { tags ->
            if (tags.isNotEmpty()) {
                query.addCriteria(Criteria.where("tags").`in`(tags))
            }
        }
        
        criteria.ageRange?.let { range ->
            query.addCriteria(Criteria.where("age").gte(range.min).lte(range.max))
        }
        
        criteria.createdAfter?.let {
            query.addCriteria(Criteria.where("created_at").gte(it))
        }
        
        // ì •ë ¬ ë° í˜ì´ì§•
        criteria.sortBy?.let { sortBy ->
            val sort = if (criteria.sortOrder == "desc") {
                Sort.by(Sort.Direction.DESC, sortBy)
            } else {
                Sort.by(Sort.Direction.ASC, sortBy)
            }
            query.with(sort)
        }
        
        criteria.limit?.let { limit ->
            query.limit(limit)
            criteria.offset?.let { offset ->
                query.skip(offset.toLong())
            }
        }
        
        return mongoTemplate.find(query, UserDocument::class.java)
    }
    
    override fun findUsersWithAggregation(): List<UserStatsDto> {
        val aggregation = Aggregation.newAggregation(
            Aggregation.match(Criteria.where("status").`is`(UserStatus.ACTIVE)),
            Aggregation.group("status")
                .count().`as`("count")
                .avg("age").`as`("avgAge")
                .first("status").`as`("status"),
            Aggregation.sort(Sort.Direction.DESC, "count")
        )
        
        return mongoTemplate.aggregate(aggregation, "users", UserStatsDto::class.java).mappedResults
    }
    
    override fun updateUserTags(userId: String, tags: List<String>): UpdateResult {
        val query = Query(Criteria.where("id").`is`(userId))
        val update = Update()
            .set("tags", tags)
            .set("updated_at", LocalDateTime.now())
        
        return mongoTemplate.updateFirst(query, update, UserDocument::class.java)
    }
}

// ê²€ìƒ‰ ì¡°ê±´ DTO
data class UserSearchCriteria(
    val name: String? = null,
    val email: String? = null,
    val status: UserStatus? = null,
    val tags: List<String>? = null,
    val ageRange: AgeRange? = null,
    val createdAfter: LocalDateTime? = null,
    val sortBy: String? = null,
    val sortOrder: String = "asc",
    val limit: Int? = null,
    val offset: Int? = null
)

data class AgeRange(val min: Int, val max: Int)
data class UserStatsDto(val status: UserStatus, val count: Long, val avgAge: Double)
```

#### 4. Service ê³„ì¸µ êµ¬í˜„

**MongoDB ì„œë¹„ìŠ¤ í´ë˜ìŠ¤**
```kotlin
@Service
@Transactional
class UserMongoService(
    private val userRepository: UserRepository,
    private val mongoTemplate: MongoTemplate
) {
    
    fun createUser(request: CreateUserRequest): UserDocument {
        // ì´ë©”ì¼ ì¤‘ë³µ ì²´í¬
        if (userRepository.existsByEmail(request.email)) {
            throw DuplicateEmailException("Email already exists: ${request.email}")
        }
        
        val userDocument = UserDocument(
            name = request.name,
            email = request.email,
            age = request.age,
            tags = request.tags ?: emptyList()
        )
        
        return userRepository.save(userDocument)
    }
    
    @Transactional(readOnly = true)
    fun getUserById(id: String): UserDocument {
        return userRepository.findById(id)
            .orElseThrow { EntityNotFoundException("User not found with id: $id") }
    }
    
    @Transactional(readOnly = true)
    fun getUserByEmail(email: String): UserDocument? {
        return userRepository.findByEmail(email)
    }
    
    @Transactional(readOnly = true)
    fun searchUsers(criteria: UserSearchCriteria): List<UserDocument> {
        return userRepository.findUsersByComplexCriteria(criteria)
    }
    
    @Transactional(readOnly = true)
    fun getUsersByStatus(status: UserStatus, pageable: Pageable): Page<UserDocument> {
        return userRepository.findByStatus(status, pageable)
    }
    
    fun updateUser(id: String, request: UpdateUserRequest): UserDocument {
        val existingUser = getUserById(id)
        
        val updatedUser = existingUser.copy(
            name = request.name ?: existingUser.name,
            age = request.age ?: existingUser.age,
            status = request.status ?: existingUser.status,
            updatedAt = LocalDateTime.now()
        )
        
        return userRepository.save(updatedUser)
    }
    
    fun addTagToUser(userId: String, tag: String): UserDocument {
        val user = getUserById(userId)
        val updatedUser = user.addTag(tag)
        return userRepository.save(updatedUser)
    }
    
    fun updateUserProfile(userId: String, profile: UserProfile): UserDocument {
        val user = getUserById(userId)
        val updatedUser = user.updateProfile(profile)
        return userRepository.save(updatedUser)
    }
    
    fun deleteUser(id: String) {
        if (!userRepository.existsById(id)) {
            throw EntityNotFoundException("User not found with id: $id")
        }
        userRepository.deleteById(id)
    }
    
    // ë²Œí¬ ì—°ì‚°
    fun updateUsersStatus(userIds: List<String>, status: UserStatus): Long {
        val query = Query(Criteria.where("id").`in`(userIds))
        val update = Update()
            .set("status", status)
            .set("updated_at", LocalDateTime.now())
        
        val result = mongoTemplate.updateMulti(query, update, UserDocument::class.java)
        return result.modifiedCount
    }
    
    // ì§‘ê³„ ì—°ì‚° ì˜ˆì œ
    @Transactional(readOnly = true)
    fun getUserStatistics(): UserStatistics {
        val totalUsers = userRepository.count()
        val activeUsers = userRepository.countByStatus(UserStatus.ACTIVE)
        val inactiveUsers = userRepository.countByStatus(UserStatus.INACTIVE)
        
        // ì§‘ê³„ íŒŒì´í”„ë¼ì¸ì„ ì‚¬ìš©í•œ í†µê³„
        val aggregation = Aggregation.newAggregation(
            Aggregation.match(Criteria.where("age").ne(null)),
            Aggregation.group()
                .avg("age").`as`("avgAge")
                .min("age").`as`("minAge")
                .max("age").`as`("maxAge")
        )
        
        val ageStats = mongoTemplate.aggregate(aggregation, "users", AgeStatistics::class.java)
            .uniqueMappedResult ?: AgeStatistics()
        
        return UserStatistics(
            totalUsers = totalUsers,
            activeUsers = activeUsers,
            inactiveUsers = inactiveUsers,
            ageStatistics = ageStats
        )
    }
}

data class UserStatistics(
    val totalUsers: Long,
    val activeUsers: Long,
    val inactiveUsers: Long,
    val ageStatistics: AgeStatistics
)

data class AgeStatistics(
    val avgAge: Double = 0.0,
    val minAge: Int = 0,
    val maxAge: Int = 0
)
```

#### 5. ê³ ê¸‰ MongoDB ê¸°ëŠ¥

**ì§‘ê³„ íŒŒì´í”„ë¼ì¸ í™œìš©**
```kotlin
@Service
class PostAnalyticsService(
    private val mongoTemplate: MongoTemplate
) {
    
    // ë³µì¡í•œ ì§‘ê³„ ì¿¼ë¦¬ ì˜ˆì œ
    fun getPostAnalytics(): PostAnalytics {
        // 1. ì¹´í…Œê³ ë¦¬ë³„ í¬ìŠ¤íŠ¸ ìˆ˜ì™€ í‰ê·  ì¡°íšŒìˆ˜
        val categoryStats = Aggregation.newAggregation(
            Aggregation.match(Criteria.where("published").`is`(true)),
            Aggregation.group("category")
                .count().`as`("postCount")
                .avg("meta.view_count").`as`("avgViews")
                .sum("meta.view_count").`as`("totalViews")
                .first("category").`as`("category"),
            Aggregation.sort(Sort.Direction.DESC, "totalViews")
        )
        
        val categoryResults = mongoTemplate.aggregate(
            categoryStats, "posts", CategoryStats::class.java
        ).mappedResults
        
        // 2. ì›”ë³„ í¬ìŠ¤íŠ¸ ë°œí–‰ íŠ¸ë Œë“œ
        val monthlyTrend = Aggregation.newAggregation(
            Aggregation.match(Criteria.where("published").`is`(true)),
            Aggregation.project()
                .and("published_at").extractYear().`as`("year")
                .and("published_at").extractMonth().`as`("month")
                .andInclude("title"),
            Aggregation.group("year", "month")
                .count().`as`("postCount"),
            Aggregation.sort(Sort.Direction.DESC, "_id.year", "_id.month")
        )
        
        val trendResults = mongoTemplate.aggregate(
            monthlyTrend, "posts", MonthlyTrend::class.java
        ).mappedResults
        
        // 3. ì¸ê¸° íƒœê·¸ ë¶„ì„
        val popularTags = Aggregation.newAggregation(
            Aggregation.match(Criteria.where("published").`is`(true)),
            Aggregation.unwind("tags"),
            Aggregation.group("tags")
                .count().`as`("count")
                .first("tags").`as`("tag"),
            Aggregation.sort(Sort.Direction.DESC, "count"),
            Aggregation.limit(10)
        )
        
        val tagResults = mongoTemplate.aggregate(
            popularTags, "posts", TagStats::class.java
        ).mappedResults
        
        return PostAnalytics(
            categoryStats = categoryResults,
            monthlyTrend = trendResults,
            popularTags = tagResults
        )
    }
    
    // ì‚¬ìš©ìë³„ í™œë™ ë¶„ì„
    fun getUserActivity(userId: String): UserActivity {
        val userPosts = Aggregation.newAggregation(
            Aggregation.match(Criteria.where("author_id").`is`(userId)),
            Aggregation.group()
                .count().`as`("totalPosts")
                .sum("meta.view_count").`as`("totalViews")
                .sum("meta.like_count").`as`("totalLikes")
                .sum("meta.comment_count").`as`("totalComments")
        )
        
        val activity = mongoTemplate.aggregate(
            userPosts, "posts", UserActivity::class.java
        ).uniqueMappedResult ?: UserActivity()
        
        return activity
    }
}

data class PostAnalytics(
    val categoryStats: List<CategoryStats>,
    val monthlyTrend: List<MonthlyTrend>,
    val popularTags: List<TagStats>
)

data class CategoryStats(
    val category: String,
    val postCount: Long,
    val avgViews: Double,
    val totalViews: Long
)

data class MonthlyTrend(
    val year: Int,
    val month: Int,
    val postCount: Long
)

data class TagStats(
    val tag: String,
    val count: Long
)

data class UserActivity(
    val totalPosts: Long = 0,
    val totalViews: Long = 0,
    val totalLikes: Long = 0,
    val totalComments: Long = 0
)
```

**MongoDB íŠ¸ëœì­ì…˜ ì‚¬ìš©**
```kotlin
@Service
@Transactional
class UserPostService(
    private val userRepository: UserRepository,
    private val postRepository: PostRepository,
    private val mongoTemplate: MongoTemplate
) {
    
    // MongoDB íŠ¸ëœì­ì…˜ì„ ì‚¬ìš©í•œ ë³µí•© ì‘ì—…
    @Transactional
    fun createUserAndFirstPost(
        userRequest: CreateUserRequest,
        postRequest: CreatePostRequest
    ): Pair<UserDocument, PostDocument> {
        
        // 1. ì‚¬ìš©ì ìƒì„±
        val user = UserDocument(
            name = userRequest.name,
            email = userRequest.email,
            age = userRequest.age
        )
        val savedUser = userRepository.save(user)
        
        // 2. ì²« ë²ˆì§¸ í¬ìŠ¤íŠ¸ ìƒì„±
        val post = PostDocument(
            title = postRequest.title,
            content = postRequest.content,
            authorId = savedUser.id!!,
            authorName = savedUser.name,
            category = postRequest.category
        )
        val savedPost = postRepository.save(post)
        
        // 3. ì‚¬ìš©ìì—ê²Œ "author" íƒœê·¸ ì¶”ê°€
        val updatedUser = savedUser.addTag("author")
        userRepository.save(updatedUser)
        
        return Pair(updatedUser, savedPost)
    }
    
    // ì„¸ì…˜ ê¸°ë°˜ íŠ¸ëœì­ì…˜ (ë” ì„¸ë°€í•œ ì œì–´)
    fun transferPostOwnership(fromUserId: String, toUserId: String, postId: String) {
        mongoTemplate.execute { session ->
            session.withTransaction {
                // 1. í¬ìŠ¤íŠ¸ ì†Œìœ ê¶Œ ë³€ê²½
                val query = Query(Criteria.where("id").`is`(postId))
                val update = Update()
                    .set("author_id", toUserId)
                    .set("updated_at", LocalDateTime.now())
                
                mongoTemplate.updateFirst(query, update, PostDocument::class.java)
                
                // 2. ì´ì „ ì†Œìœ ìì˜ í¬ìŠ¤íŠ¸ ìˆ˜ ê°ì†Œ (ë©”íƒ€ë°ì´í„°ê°€ ìˆë‹¤ë©´)
                // 3. ìƒˆ ì†Œìœ ìì˜ í¬ìŠ¤íŠ¸ ìˆ˜ ì¦ê°€
                // ... ì¶”ê°€ ë¡œì§
                
                null // ë°˜í™˜ê°’
            }
        }
    }
}
```

#### 6. ì„±ëŠ¥ ìµœì í™”

**ì¸ë±ìŠ¤ ì„¤ì •**
```kotlin
@Configuration
class MongoIndexConfig(
    private val mongoTemplate: MongoTemplate
) {
    
    @PostConstruct
    fun initIndexes() {
        // Users ì»¬ë ‰ì…˜ ì¸ë±ìŠ¤
        mongoTemplate.indexOps(UserDocument::class.java).apply {
            // ì´ë©”ì¼ ìœ ë‹ˆí¬ ì¸ë±ìŠ¤
            ensureIndex(
                Index().on("email", Sort.Direction.ASC).unique()
            )
            
            // ìƒíƒœë³„ ì¡°íšŒ ì¸ë±ìŠ¤
            ensureIndex(
                Index().on("status", Sort.Direction.ASC)
            )
            
            // íƒœê·¸ ê²€ìƒ‰ ì¸ë±ìŠ¤
            ensureIndex(
                Index().on("tags", Sort.Direction.ASC)
            )
            
            // ìƒì„±ì¼ì‹œ ì¸ë±ìŠ¤ (TTL ì„¤ì • ê°€ëŠ¥)
            ensureIndex(
                Index().on("created_at", Sort.Direction.DESC)
            )
            
            // ë³µí•© ì¸ë±ìŠ¤
            ensureIndex(
                Index()
                    .on("status", Sort.Direction.ASC)
                    .on("created_at", Sort.Direction.DESC)
            )
        }
        
        // Posts ì»¬ë ‰ì…˜ ì¸ë±ìŠ¤
        mongoTemplate.indexOps(PostDocument::class.java).apply {
            // ì¹´í…Œê³ ë¦¬ë³„ ì¸ë±ìŠ¤
            ensureIndex(Index().on("category", Sort.Direction.ASC))
            
            // ì‘ì„±ìë³„ ì¸ë±ìŠ¤
            ensureIndex(Index().on("author_id", Sort.Direction.ASC))
            
            // ë°œí–‰ì¼ì‹œ ì¸ë±ìŠ¤
            ensureIndex(Index().on("published_at", Sort.Direction.DESC))
            
            // í…ìŠ¤íŠ¸ ê²€ìƒ‰ ì¸ë±ìŠ¤
            ensureIndex(
                Index()
                    .on("title", Sort.Direction.ASC)
                    .on("content", Sort.Direction.ASC)
                    .named("text_search")
            )
            
            // ë³µí•© ì¸ë±ìŠ¤ (ë°œí–‰ëœ í¬ìŠ¤íŠ¸ì˜ ì¹´í…Œê³ ë¦¬ë³„ ì •ë ¬)
            ensureIndex(
                Index()
                    .on("published", Sort.Direction.ASC)
                    .on("category", Sort.Direction.ASC)
                    .on("published_at", Sort.Direction.DESC)
            )
        }
    }
}
```

**ì¿¼ë¦¬ ìµœì í™” íŒ**
```kotlin
@Service
class OptimizedQueryService(
    private val mongoTemplate: MongoTemplate
) {
    
    // âœ… ì¢‹ì€ ì˜ˆ: í•„ìš”í•œ í•„ë“œë§Œ í”„ë¡œì ì…˜
    fun getUserBasicInfo(userId: String): UserBasicInfo? {
        val query = Query(Criteria.where("id").`is`(userId))
        query.fields()
            .include("name")
            .include("email")
            .include("status")
        
        return mongoTemplate.findOne(query, UserBasicInfo::class.java, "users")
    }
    
    // âœ… ì¢‹ì€ ì˜ˆ: ì¸ë±ìŠ¤ë¥¼ í™œìš©í•œ ì •ë ¬
    fun getRecentActiveUsers(limit: Int): List<UserDocument> {
        val query = Query(Criteria.where("status").`is`(UserStatus.ACTIVE))
        query.with(Sort.by(Sort.Direction.DESC, "created_at"))
        query.limit(limit)
        
        return mongoTemplate.find(query, UserDocument::class.java)
    }
    
    // âœ… ì¢‹ì€ ì˜ˆ: ë²Œí¬ ì—°ì‚° ì‚¬ìš©
    fun markUsersAsInactive(userIds: List<String>): Long {
        val query = Query(Criteria.where("id").`in`(userIds))
        val update = Update()
            .set("status", UserStatus.INACTIVE)
            .set("updated_at", LocalDateTime.now())
        
        return mongoTemplate.updateMulti(query, update, UserDocument::class.java).modifiedCount
    }
    
    // âŒ ë‚˜ìœ ì˜ˆ: ì „ì²´ ì»¬ë ‰ì…˜ ìŠ¤ìº”
    fun getAllUsersWithoutPaging(): List<UserDocument> {
        return mongoTemplate.findAll(UserDocument::class.java) // ìœ„í—˜!
    }
    
    // âœ… ì¢‹ì€ ì˜ˆ: í˜ì´ì§•ê³¼ ì œí•œ ì‚¬ìš©
    fun getUsersWithPaging(page: Int, size: Int): List<UserDocument> {
        val pageable = PageRequest.of(page, size, Sort.by("created_at").descending())
        val query = Query().with(pageable)
        
        return mongoTemplate.find(query, UserDocument::class.java)
    }
}

data class UserBasicInfo(
    val name: String,
    val email: String,
    val status: UserStatus
)
```

#### 7. MongoDB ê°œë°œ/ìš´ì˜ íŒ

**ê°œë°œ í™˜ê²½ ì„¤ì •**
```bash
# Dockerë¡œ MongoDB ì‹¤í–‰
docker run -d --name mongodb -p 27017:27017 -e MONGO_INITDB_ROOT_USERNAME=admin -e MONGO_INITDB_ROOT_PASSWORD=password mongo:7

# MongoDB Compass ì—°ê²°
mongodb://admin:password@localhost:27017/

# MongoDB CLI ì ‘ì†
docker exec -it mongodb mongosh

# ê¸°ë³¸ ëª…ë ¹ì–´
show dbs
use appdb
db.users.find()
db.users.createIndex({"email": 1}, {"unique": true})
```

**ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§**
```kotlin
@Component
class MongoHealthIndicator(
    private val mongoTemplate: MongoTemplate
) : HealthIndicator {
    
    override fun health(): Health {
        return try {
            val dbStats = mongoTemplate.execute { db ->
                db.runCommand(Document("dbStats", 1))
            }
            
            Health.up()
                .withDetail("mongodb", "Available")
                .withDetail("database", dbStats?.getString("db"))
                .withDetail("collections", dbStats?.getInteger("collections"))
                .withDetail("dataSize", dbStats?.get("dataSize"))
                .build()
        } catch (e: Exception) {
            Health.down()
                .withDetail("mongodb", "Not Available")
                .withException(e)
                .build()
        }
    }
}
```

**ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤**
- **ë¬¸ì„œ ì„¤ê³„**: ì„ë² ë””ë“œ vs ì°¸ì¡° ì „ëµì„ ì‹ ì¤‘íˆ ì„ íƒ
- **ì¸ë±ìŠ¤ ì „ëµ**: ì¿¼ë¦¬ íŒ¨í„´ì— ë§ëŠ” ì¸ë±ìŠ¤ ì„¤ê³„
- **ë°ì´í„° ëª¨ë¸ë§**: ì½ê¸° íŒ¨í„´ì— ìµœì í™”ëœ ìŠ¤í‚¤ë§ˆ ì„¤ê³„
- **ì§‘ê³„ íŒŒì´í”„ë¼ì¸**: ë³µì¡í•œ ë¶„ì„ì€ ì§‘ê³„ í™œìš©
- **íŠ¸ëœì­ì…˜**: í•„ìš”í•œ ê²½ìš°ì—ë§Œ ì‚¬ìš© (ì„±ëŠ¥ ê³ ë ¤)
- **ìƒ¤ë”©**: ëŒ€ìš©ëŸ‰ ë°ì´í„°ì˜ ê²½ìš° ìƒ¤ë”© ì „ëµ ê³ ë ¤

### REST API ì„¤ê³„ ê°€ì´ë“œ

#### RESTful Endpoint ì„¤ê³„ ì›ì¹™

**1. ë¦¬ì†ŒìŠ¤ ì¤‘ì‹¬ ì„¤ê³„**
```bash
# âœ… ì¢‹ì€ ì˜ˆ: ëª…ì‚¬í˜• ë¦¬ì†ŒìŠ¤ ì‚¬ìš©
GET    /api/v1/users          # ì‚¬ìš©ì ëª©ë¡ ì¡°íšŒ
POST   /api/v1/users          # ì‚¬ìš©ì ìƒì„±
GET    /api/v1/users/{id}     # íŠ¹ì • ì‚¬ìš©ì ì¡°íšŒ
PUT    /api/v1/users/{id}     # ì‚¬ìš©ì ì „ì²´ ìˆ˜ì •
PATCH  /api/v1/users/{id}     # ì‚¬ìš©ì ë¶€ë¶„ ìˆ˜ì •
DELETE /api/v1/users/{id}     # ì‚¬ìš©ì ì‚­ì œ

# âŒ ë‚˜ìœ ì˜ˆ: ë™ì‚¬í˜• ì‚¬ìš©
POST /api/v1/createUser       # ë™ì‚¬ ì‚¬ìš© ê¸ˆì§€
GET  /api/v1/getUser/{id}     # ë™ì‚¬ ì‚¬ìš© ê¸ˆì§€
POST /api/v1/deleteUser/{id}  # ì˜ëª»ëœ HTTP ë©”ì„œë“œ
```

**2. HTTP ë©”ì„œë“œë³„ ì‚¬ìš© ê·œì¹™**

| HTTP ë©”ì„œë“œ | ëª©ì  | ë©±ë“±ì„± | ìš”ì²­ Body | ì‘ë‹µ Body |
|-------------|------|--------|-----------|-----------|
| **GET** | ì¡°íšŒ | âœ… | âŒ | âœ… |
| **POST** | ìƒì„± | âŒ | âœ… | âœ… |
| **PUT** | ì „ì²´ ìˆ˜ì • | âœ… | âœ… | âœ… |
| **PATCH** | ë¶€ë¶„ ìˆ˜ì • | âŒ | âœ… | âœ… |
| **DELETE** | ì‚­ì œ | âœ… | âŒ | âœ… |

**3. URL íŒ¨í„´ ë° ëª…ëª… ê·œì¹™**
```bash
# ê¸°ë³¸ íŒ¨í„´: /api/{version}/{resource}
/api/v1/users
/api/v1/orders
/api/v1/products

# ê³„ì¸µì  ë¦¬ì†ŒìŠ¤: ë¶€ëª¨/ìì‹ ê´€ê³„
GET    /api/v1/users/{userId}/orders           # íŠ¹ì • ì‚¬ìš©ìì˜ ì£¼ë¬¸ ëª©ë¡
POST   /api/v1/users/{userId}/orders           # íŠ¹ì • ì‚¬ìš©ìì˜ ì£¼ë¬¸ ìƒì„±
GET    /api/v1/users/{userId}/orders/{orderId} # íŠ¹ì • ì‚¬ìš©ìì˜ íŠ¹ì • ì£¼ë¬¸
PUT    /api/v1/orders/{orderId}/items/{itemId} # ì£¼ë¬¸ì˜ íŠ¹ì • ì•„ì´í…œ ìˆ˜ì •

# ë³µí•© ë¦¬ì†ŒìŠ¤ ì¡°íšŒ
GET /api/v1/orders/{orderId}/items              # ì£¼ë¬¸ì˜ ì•„ì´í…œ ëª©ë¡
GET /api/v1/categories/{categoryId}/products    # ì¹´í…Œê³ ë¦¬ë³„ ìƒí’ˆ ëª©ë¡
```

**4. ì¿¼ë¦¬ íŒŒë¼ë¯¸í„° í™œìš©**
```bash
# í•„í„°ë§
GET /api/v1/users?status=active&role=admin
GET /api/v1/orders?status=pending&userId=123

# ì •ë ¬
GET /api/v1/users?sort=createdAt,desc
GET /api/v1/products?sort=price,asc&sort=name,desc

# í˜ì´ì§•
GET /api/v1/users?page=0&size=20
GET /api/v1/orders?page=1&size=50&sort=createdAt,desc

# ê²€ìƒ‰
GET /api/v1/users?search=john
GET /api/v1/products?name=contains:phone&price=gte:100000

# í•„ë“œ ì„ íƒ (ë¶€ë¶„ ì‘ë‹µ)
GET /api/v1/users?fields=id,name,email
GET /api/v1/orders?fields=id,status,totalAmount
```

**5. HTTP ìƒíƒœ ì½”ë“œ ê°€ì´ë“œ**

**ì„±ê³µ ì‘ë‹µ (2xx)**
```kotlin
// 200 OK: ì¡°íšŒ/ìˆ˜ì • ì„±ê³µ
@GetMapping("/{id}")
@ResponseStatus(HttpStatus.OK)
fun getUser(@PathVariable id: Long): ApiResponse<UserResponse>

// 201 Created: ìƒì„± ì„±ê³µ
@PostMapping
@ResponseStatus(HttpStatus.CREATED)
fun createUser(@RequestBody request: CreateUserRequest): ApiResponse<UserResponse>

// 204 No Content: ì‚­ì œ ì„±ê³µ (ì‘ë‹µ Body ì—†ìŒ)
@DeleteMapping("/{id}")
@ResponseStatus(HttpStatus.NO_CONTENT)
fun deleteUser(@PathVariable id: Long)
```

**í´ë¼ì´ì–¸íŠ¸ ì˜¤ë¥˜ (4xx)**
```kotlin
// 400 Bad Request: ì˜ëª»ëœ ìš”ì²­
return ResponseEntity.badRequest().body(
    ApiResponse.failure("Invalid request parameters")
)

// 401 Unauthorized: ì¸ì¦ í•„ìš”
return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(
    ApiResponse.failure("Authentication required")
)

// 403 Forbidden: ê¶Œí•œ ì—†ìŒ
return ResponseEntity.status(HttpStatus.FORBIDDEN).body(
    ApiResponse.failure("Access denied")
)

// 404 Not Found: ë¦¬ì†ŒìŠ¤ ì—†ìŒ
return ResponseEntity.notFound().build()

// 409 Conflict: ë¦¬ì†ŒìŠ¤ ì¶©ëŒ
return ResponseEntity.status(HttpStatus.CONFLICT).body(
    ApiResponse.failure("Email already exists")
)

// 422 Unprocessable Entity: ê²€ì¦ ì‹¤íŒ¨
return ResponseEntity.unprocessableEntity().body(
    ApiResponse.failure("Validation failed", errors)
)
```

**6. API ë²„ì €ë‹ ì „ëµ**
```bash
# URL ë²„ì €ë‹ (ê¶Œì¥)
/api/v1/users
/api/v2/users

# Header ë²„ì €ë‹
GET /api/users
Accept: application/vnd.company.v1+json

# íŒŒë¼ë¯¸í„° ë²„ì €ë‹
GET /api/users?version=1
```

**7. ì‹¤ì œ Controller êµ¬í˜„ ì˜ˆì œ**
```kotlin
@RestController
@RequestMapping("/api/v1/users")
@Validated
class UserController(
    private val userApplicationService: UserApplicationService
) {
    
    // ì‚¬ìš©ì ëª©ë¡ ì¡°íšŒ (í˜ì´ì§•, í•„í„°ë§, ì •ë ¬)
    @GetMapping
    fun getUsers(
        @RequestParam(defaultValue = "0") @Min(0) page: Int,
        @RequestParam(defaultValue = "20") @Min(1) @Max(100) size: Int,
        @RequestParam(defaultValue = "createdAt,desc") sort: String,
        @RequestParam(required = false) status: UserStatus?,
        @RequestParam(required = false) search: String?
    ): ResponseEntity<ApiResponse<Page<UserResponse>>> {
        
        val pageable = PageRequest.of(page, size, parseSort(sort))
        val users = userApplicationService.getUsers(pageable, status, search)
        
        return ResponseEntity.ok(ApiResponse.success(users))
    }
    
    // íŠ¹ì • ì‚¬ìš©ì ì¡°íšŒ
    @GetMapping("/{id}")
    fun getUserById(
        @PathVariable @Min(1) id: Long
    ): ResponseEntity<ApiResponse<UserResponse>> {
        val user = userApplicationService.getUserById(id)
        return ResponseEntity.ok(ApiResponse.success(user))
    }
    
    // ì‚¬ìš©ì ìƒì„±
    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    fun createUser(
        @Valid @RequestBody request: CreateUserRequest
    ): ResponseEntity<ApiResponse<UserResponse>> {
        val command = CreateUserCommand(
            name = request.name,
            email = request.email
        )
        
        val user = userApplicationService.createUser(command)
        
        return ResponseEntity.status(HttpStatus.CREATED).body(
            ApiResponse.success(
                data = user,
                message = "User created successfully"
            )
        )
    }
    
    // ì‚¬ìš©ì ì „ì²´ ìˆ˜ì •
    @PutMapping("/{id}")
    fun updateUser(
        @PathVariable @Min(1) id: Long,
        @Valid @RequestBody request: UpdateUserRequest
    ): ResponseEntity<ApiResponse<UserResponse>> {
        val command = UpdateUserCommand(
            id = id,
            name = request.name,
            email = request.email,
            status = request.status
        )
        
        val user = userApplicationService.updateUser(command)
        
        return ResponseEntity.ok(
            ApiResponse.success(
                data = user,
                message = "User updated successfully"
            )
        )
    }
    
    // ì‚¬ìš©ì ë¶€ë¶„ ìˆ˜ì •
    @PatchMapping("/{id}")
    fun patchUser(
        @PathVariable @Min(1) id: Long,
        @Valid @RequestBody request: PatchUserRequest
    ): ResponseEntity<ApiResponse<UserResponse>> {
        val command = PatchUserCommand(
            id = id,
            name = request.name,
            status = request.status
        )
        
        val user = userApplicationService.patchUser(command)
        
        return ResponseEntity.ok(
            ApiResponse.success(
                data = user,
                message = "User updated successfully"
            )
        )
    }
    
    // ì‚¬ìš©ì ì‚­ì œ
    @DeleteMapping("/{id}")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    fun deleteUser(
        @PathVariable @Min(1) id: Long
    ): ResponseEntity<Void> {
        userApplicationService.deleteUser(id)
        return ResponseEntity.noContent().build()
    }
    
    // ì‚¬ìš©ìì˜ ì£¼ë¬¸ ëª©ë¡ ì¡°íšŒ (ê³„ì¸µì  ë¦¬ì†ŒìŠ¤)
    @GetMapping("/{userId}/orders")
    fun getUserOrders(
        @PathVariable @Min(1) userId: Long,
        @RequestParam(defaultValue = "0") @Min(0) page: Int,
        @RequestParam(defaultValue = "20") @Min(1) @Max(100) size: Int
    ): ResponseEntity<ApiResponse<Page<OrderResponse>>> {
        val pageable = PageRequest.of(page, size)
        val orders = orderApplicationService.getOrdersByUserId(userId, pageable)
        
        return ResponseEntity.ok(ApiResponse.success(orders))
    }
    
    // ì •ë ¬ íŒŒë¼ë¯¸í„° íŒŒì‹± ìœ í‹¸ë¦¬í‹°
    private fun parseSort(sortParam: String): Sort {
        return try {
            val parts = sortParam.split(",")
            val property = parts[0]
            val direction = if (parts.size > 1 && parts[1].lowercase() == "desc") {
                Sort.Direction.DESC
            } else {
                Sort.Direction.ASC
            }
            Sort.by(direction, property)
        } catch (e: Exception) {
            Sort.by(Sort.Direction.DESC, "createdAt")  // ê¸°ë³¸ê°’
        }
    }
}
```

**8. ìš”ì²­/ì‘ë‹µ DTO ì„¤ê³„**
```kotlin
// ìƒì„± ìš”ì²­ DTO
data class CreateUserRequest(
    @field:NotBlank(message = "Name is required")
    @field:Size(min = 2, max = 50, message = "Name must be between 2 and 50 characters")
    val name: String,
    
    @field:NotBlank(message = "Email is required")
    @field:Email(message = "Invalid email format")
    val email: String
)

// ì „ì²´ ìˆ˜ì • ìš”ì²­ DTO (ëª¨ë“  í•„ë“œ í•„ìˆ˜)
data class UpdateUserRequest(
    @field:NotBlank(message = "Name is required")
    @field:Size(min = 2, max = 50)
    val name: String,
    
    @field:NotBlank(message = "Email is required")
    @field:Email(message = "Invalid email format")
    val email: String,
    
    @field:NotNull(message = "Status is required")
    val status: UserStatus
)

// ë¶€ë¶„ ìˆ˜ì • ìš”ì²­ DTO (ëª¨ë“  í•„ë“œ ì„ íƒì‚¬í•­)
data class PatchUserRequest(
    @field:Size(min = 2, max = 50, message = "Name must be between 2 and 50 characters")
    val name: String? = null,
    
    val status: UserStatus? = null
)

// ì‘ë‹µ DTO
data class UserResponse(
    val id: Long,
    val name: String,
    val email: String,
    val status: String,
    val createdAt: LocalDateTime,
    val updatedAt: LocalDateTime
) {
    companion object {
        fun from(user: User): UserResponse {
            return UserResponse(
                id = user.id,
                name = user.name,
                email = user.email.toString(),
                status = user.status.name,
                createdAt = user.createdAt,
                updatedAt = user.updatedAt
            )
        }
    }
}
```

**9. API ë¬¸ì„œí™” (OpenAPI/Swagger)**
```kotlin
@RestController
@RequestMapping("/api/v1/users")
@Tag(name = "User", description = "ì‚¬ìš©ì ê´€ë¦¬ API")
class UserController {
    
    @Operation(
        summary = "ì‚¬ìš©ì ëª©ë¡ ì¡°íšŒ",
        description = "í˜ì´ì§•, í•„í„°ë§, ì •ë ¬ì´ ê°€ëŠ¥í•œ ì‚¬ìš©ì ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤."
    )
    @ApiResponses(value = [
        ApiResponse(responseCode = "200", description = "ì¡°íšŒ ì„±ê³µ"),
        ApiResponse(responseCode = "400", description = "ì˜ëª»ëœ ìš”ì²­ íŒŒë¼ë¯¸í„°")
    ])
    @GetMapping
    fun getUsers(
        @Parameter(description = "í˜ì´ì§€ ë²ˆí˜¸ (0ë¶€í„° ì‹œì‘)", example = "0")
        @RequestParam(defaultValue = "0") page: Int,
        
        @Parameter(description = "í˜ì´ì§€ í¬ê¸°", example = "20")
        @RequestParam(defaultValue = "20") size: Int
    ): ResponseEntity<ApiResponse<Page<UserResponse>>> {
        // êµ¬í˜„
    }
}
```

## í”„ë¡ íŠ¸ì—”ë“œ ìƒì„¸ ì½”ë”© ê°€ì´ë“œ

### React.js ì½”ë”© ìŠ¤íƒ€ì¼

#### ì»´í¬ë„ŒíŠ¸ ëª…ëª… ê·œì¹™
```javascript
// âœ… ì¢‹ì€ ì˜ˆ: PascalCase ì‚¬ìš©
const UserProfile = () => {
  return <div>User Profile</div>;
};

// âœ… íŒŒì¼ëª…ë„ PascalCase
// UserProfile.jsx

// âŒ ë‚˜ìœ ì˜ˆ: camelCase ì‚¬ìš©
const userProfile = () => {
  return <div>User Profile</div>;
};
```

#### í•¨ìˆ˜í˜• ì»´í¬ë„ŒíŠ¸ vs í´ë˜ìŠ¤í˜• ì»´í¬ë„ŒíŠ¸
```javascript
// âœ… ê¶Œì¥: í•¨ìˆ˜í˜• ì»´í¬ë„ŒíŠ¸ + Hooks ì‚¬ìš©
const UserList = () => {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    fetchUsers();
  }, []);

  const fetchUsers = async () => {
    setLoading(true);
    try {
      const response = await userApi.getUsers();
      setUsers(response.data);
    } catch (error) {
      console.error('Failed to fetch users:', error);
    } finally {
      setLoading(false);
    }
  };

  if (loading) return <div>Loading...</div>;

  return (
    <div className="user-list">
      {users.map(user => (
        <UserCard key={user.id} user={user} />
      ))}
    </div>
  );
};

// âŒ ì§€ì–‘: í´ë˜ìŠ¤í˜• ì»´í¬ë„ŒíŠ¸ (íŠ¹ë³„í•œ ê²½ìš° ì œì™¸)
class UserList extends Component {
  // êµ¬ì‹ ë°©ì‹
}
```

### ì»´í¬ë„ŒíŠ¸ ì„¤ê³„ ì›ì¹™

#### 1. Single Responsibility Principle (ë‹¨ì¼ ì±…ì„ ì›ì¹™)
```javascript
// âœ… ì¢‹ì€ ì˜ˆ: ê°ê°ì˜ ì±…ì„ì´ ëª…í™•
const UserCard = ({ user, onEdit, onDelete }) => {
  return (
    <div className="user-card">
      <UserAvatar src={user.avatar} alt={user.name} />
      <UserInfo user={user} />
      <UserActions onEdit={onEdit} onDelete={onDelete} />
    </div>
  );
};

const UserAvatar = ({ src, alt }) => (
  <img src={src} alt={alt} className="user-avatar" />
);

const UserInfo = ({ user }) => (
  <div className="user-info">
    <h3>{user.name}</h3>
    <p>{user.email}</p>
  </div>
);

const UserActions = ({ onEdit, onDelete }) => (
  <div className="user-actions">
    <button onClick={onEdit}>Edit</button>
    <button onClick={onDelete}>Delete</button>
  </div>
);

// âŒ ë‚˜ìœ ì˜ˆ: í•˜ë‚˜ì˜ ì»´í¬ë„ŒíŠ¸ì— ëª¨ë“  ì±…ì„
const UserCard = ({ user, onEdit, onDelete }) => {
  return (
    <div className="user-card">
      <img src={user.avatar} alt={user.name} className="user-avatar" />
      <div className="user-info">
        <h3>{user.name}</h3>
        <p>{user.email}</p>
      </div>
      <div className="user-actions">
        <button onClick={onEdit}>Edit</button>
        <button onClick={onDelete}>Delete</button>
      </div>
      {/* ë„ˆë¬´ ë§ì€ ë¡œì§ì´ í•œ ê³³ì—... */}
    </div>
  );
};
```

#### 2. Props ì„¤ê³„ ë° ê²€ì¦
```javascript
import PropTypes from 'prop-types';

// âœ… ì¢‹ì€ ì˜ˆ: ëª…í™•í•œ Props ì¸í„°í˜ì´ìŠ¤
const UserProfile = ({ 
  user, 
  isEditing, 
  onEdit, 
  onSave, 
  onCancel 
}) => {
  return (
    <div className="user-profile">
      {isEditing ? (
        <UserEditForm 
          user={user} 
          onSave={onSave} 
          onCancel={onCancel} 
        />
      ) : (
        <UserDisplay 
          user={user} 
          onEdit={onEdit} 
        />
      )}
    </div>
  );
};

// Props ê²€ì¦
UserProfile.propTypes = {
  user: PropTypes.shape({
    id: PropTypes.number.isRequired,
    name: PropTypes.string.isRequired,
    email: PropTypes.string.isRequired,
    avatar: PropTypes.string
  }).isRequired,
  isEditing: PropTypes.bool,
  onEdit: PropTypes.func.isRequired,
  onSave: PropTypes.func.isRequired,
  onCancel: PropTypes.func.isRequired
};

// ê¸°ë³¸ê°’ ì„¤ì •
UserProfile.defaultProps = {
  isEditing: false
};
```

### Hooks ì‚¬ìš© ê°€ì´ë“œ

#### 1. useState ìµœì í™”
```javascript
// âœ… ì¢‹ì€ ì˜ˆ: ê´€ë ¨ëœ ìƒíƒœë¥¼ ê°ì²´ë¡œ ê·¸ë£¹í™”
const UserForm = () => {
  const [formData, setFormData] = useState({
    name: '',
    email: '',
    phone: ''
  });
  
  const [formState, setFormState] = useState({
    loading: false,
    errors: {},
    isValid: false
  });

  const handleInputChange = (field, value) => {
    setFormData(prev => ({
      ...prev,
      [field]: value
    }));
  };

  const validateForm = () => {
    const errors = {};
    if (!formData.name.trim()) errors.name = 'Name is required';
    if (!formData.email.trim()) errors.email = 'Email is required';
    
    setFormState(prev => ({
      ...prev,
      errors,
      isValid: Object.keys(errors).length === 0
    }));
  };

  return (
    <form>
      <input
        value={formData.name}
        onChange={(e) => handleInputChange('name', e.target.value)}
        onBlur={validateForm}
      />
      {formState.errors.name && (
        <span className="error">{formState.errors.name}</span>
      )}
    </form>
  );
};

// âŒ ë‚˜ìœ ì˜ˆ: ë„ˆë¬´ ë§ì€ ê°œë³„ state
const UserForm = () => {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [phone, setPhone] = useState('');
  const [loading, setLoading] = useState(false);
  const [nameError, setNameError] = useState('');
  const [emailError, setEmailError] = useState('');
  // ìƒíƒœê°€ í©ì–´ì ¸ì„œ ê´€ë¦¬ê°€ ì–´ë ¤ì›€
};
```

#### 2. useEffect ìµœì í™”
```javascript
// âœ… ì¢‹ì€ ì˜ˆ: ì˜ì¡´ì„± ë°°ì—´ ëª…ì‹œì  ê´€ë¦¬
const UserProfile = ({ userId }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(false);

  // ì‚¬ìš©ì ë°ì´í„° ë¡œë”©
  useEffect(() => {
    const fetchUser = async () => {
      setLoading(true);
      try {
        const userData = await userApi.getUser(userId);
        setUser(userData);
      } catch (error) {
        console.error('Failed to fetch user:', error);
      } finally {
        setLoading(false);
      }
    };

    if (userId) {
      fetchUser();
    }
  }, [userId]); // userIdê°€ ë³€ê²½ë  ë•Œë§Œ ì‹¤í–‰

  // í´ë¦°ì—… í•¨ìˆ˜ ì‚¬ìš©
  useEffect(() => {
    const timer = setInterval(() => {
      // ì£¼ê¸°ì  ì—…ë°ì´íŠ¸
    }, 5000);

    return () => clearInterval(timer); // í´ë¦°ì—…
  }, []);

  return loading ? <div>Loading...</div> : <UserDetails user={user} />;
};

// âŒ ë‚˜ìœ ì˜ˆ: ì˜ì¡´ì„± ë°°ì—´ ëˆ„ë½
const UserProfile = ({ userId }) => {
  const [user, setUser] = useState(null);

  useEffect(() => {
    userApi.getUser(userId).then(setUser);
  }); // ì˜ì¡´ì„± ë°°ì—´ ì—†ìŒ - ë¬´í•œ ë£¨í”„!
};
```

#### 3. ì»¤ìŠ¤í…€ Hook í™œìš©
```javascript
// âœ… ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ì»¤ìŠ¤í…€ Hook
const useApi = (apiCall, dependencies = []) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const execute = useCallback(async (...args) => {
    setLoading(true);
    setError(null);
    
    try {
      const result = await apiCall(...args);
      setData(result);
      return result;
    } catch (err) {
      setError(err);
      throw err;
    } finally {
      setLoading(false);
    }
  }, dependencies);

  return { data, loading, error, execute };
};

// ì‚¬ìš© ì˜ˆì‹œ
const UserList = () => {
  const { 
    data: users, 
    loading, 
    error, 
    execute: fetchUsers 
  } = useApi(userApi.getUsers);

  useEffect(() => {
    fetchUsers();
  }, [fetchUsers]);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      {users?.map(user => (
        <UserCard key={user.id} user={user} />
      ))}
    </div>
  );
};

// Form ê´€ë¦¬ìš© ì»¤ìŠ¤í…€ Hook
const useForm = (initialValues, validationRules) => {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});

  const setValue = (field, value) => {
    setValues(prev => ({ ...prev, [field]: value }));
  };

  const setTouched = (field) => {
    setTouched(prev => ({ ...prev, [field]: true }));
  };

  const validate = () => {
    const newErrors = {};
    Object.keys(validationRules).forEach(field => {
      const rule = validationRules[field];
      const value = values[field];
      
      if (rule.required && (!value || value.trim() === '')) {
        newErrors[field] = `${field} is required`;
      } else if (rule.pattern && !rule.pattern.test(value)) {
        newErrors[field] = rule.message;
      }
    });
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const reset = () => {
    setValues(initialValues);
    setErrors({});
    setTouched({});
  };

  return {
    values,
    errors,
    touched,
    setValue,
    setTouched,
    validate,
    reset,
    isValid: Object.keys(errors).length === 0
  };
};
```

### ìƒíƒœ ê´€ë¦¬ íŒ¨í„´

#### 1. Local State vs Global State
```javascript
// âœ… Local State: ì»´í¬ë„ŒíŠ¸ ë‚´ë¶€ì—ì„œë§Œ ì‚¬ìš©
const UserCard = ({ user }) => {
  const [isExpanded, setIsExpanded] = useState(false);
  const [isEditing, setIsEditing] = useState(false);

  return (
    <div className="user-card">
      <button onClick={() => setIsExpanded(!isExpanded)}>
        {isExpanded ? 'Collapse' : 'Expand'}
      </button>
      {isExpanded && <UserDetails user={user} />}
    </div>
  );
};

// âœ… Global State: Context API ì‚¬ìš©
const UserContext = createContext();

const UserProvider = ({ children }) => {
  const [currentUser, setCurrentUser] = useState(null);
  const [users, setUsers] = useState([]);

  const login = async (credentials) => {
    const user = await authApi.login(credentials);
    setCurrentUser(user);
  };

  const logout = () => {
    setCurrentUser(null);
  };

  return (
    <UserContext.Provider value={{
      currentUser,
      users,
      login,
      logout,
      setUsers
    }}>
      {children}
    </UserContext.Provider>
  );
};

// ì‚¬ìš©
const useUser = () => {
  const context = useContext(UserContext);
  if (!context) {
    throw new Error('useUser must be used within UserProvider');
  }
  return context;
};
```

#### 2. Redux Toolkit ì‚¬ìš© (ë³µì¡í•œ ìƒíƒœ ê´€ë¦¬)
```javascript
// store/userSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';

// ë¹„ë™ê¸° ì•¡ì…˜
export const fetchUsers = createAsyncThunk(
  'users/fetchUsers',
  async (_, { rejectWithValue }) => {
    try {
      const response = await userApi.getUsers();
      return response.data;
    } catch (error) {
      return rejectWithValue(error.response.data);
    }
  }
);

const userSlice = createSlice({
  name: 'users',
  initialState: {
    users: [],
    currentUser: null,
    loading: false,
    error: null
  },
  reducers: {
    setCurrentUser: (state, action) => {
      state.currentUser = action.payload;
    },
    clearError: (state) => {
      state.error = null;
    }
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchUsers.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchUsers.fulfilled, (state, action) => {
        state.loading = false;
        state.users = action.payload;
      })
      .addCase(fetchUsers.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload;
      });
  }
});

export const { setCurrentUser, clearError } = userSlice.actions;
export default userSlice.reducer;

// ì»´í¬ë„ŒíŠ¸ì—ì„œ ì‚¬ìš©
const UserList = () => {
  const dispatch = useDispatch();
  const { users, loading, error } = useSelector(state => state.users);

  useEffect(() => {
    dispatch(fetchUsers());
  }, [dispatch]);

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;

  return (
    <div>
      {users.map(user => (
        <UserCard key={user.id} user={user} />
      ))}
    </div>
  );
};
```

### ì„±ëŠ¥ ìµœì í™”

#### 1. React.memoì™€ useMemo, useCallback
```javascript
// âœ… React.memoë¡œ ë¶ˆí•„ìš”í•œ ë¦¬ë Œë”ë§ ë°©ì§€
const UserCard = React.memo(({ user, onEdit, onDelete }) => {
  console.log('UserCard rendered for:', user.name);
  
  return (
    <div className="user-card">
      <h3>{user.name}</h3>
      <p>{user.email}</p>
      <button onClick={() => onEdit(user.id)}>Edit</button>
      <button onClick={() => onDelete(user.id)}>Delete</button>
    </div>
  );
});

// Props ë¹„êµ í•¨ìˆ˜ (ì„ íƒì‚¬í•­)
const UserCard = React.memo(({ user, onEdit, onDelete }) => {
  // ì»´í¬ë„ŒíŠ¸ ë‚´ìš©
}, (prevProps, nextProps) => {
  return prevProps.user.id === nextProps.user.id &&
         prevProps.user.name === nextProps.user.name &&
         prevProps.user.email === nextProps.user.email;
});

// âœ… useMemoë¡œ ë¹„ì‹¼ ê³„ì‚° ìµœì í™”
const UserStatistics = ({ users }) => {
  const statistics = useMemo(() => {
    console.log('Calculating statistics...');
    return {
      totalUsers: users.length,
      activeUsers: users.filter(user => user.status === 'active').length,
      averageAge: users.reduce((sum, user) => sum + user.age, 0) / users.length
    };
  }, [users]); // usersê°€ ë³€ê²½ë  ë•Œë§Œ ì¬ê³„ì‚°

  return (
    <div>
      <p>Total Users: {statistics.totalUsers}</p>
      <p>Active Users: {statistics.activeUsers}</p>
      <p>Average Age: {statistics.averageAge}</p>
    </div>
  );
};

// âœ… useCallbackìœ¼ë¡œ í•¨ìˆ˜ ìµœì í™”
const UserList = () => {
  const [users, setUsers] = useState([]);
  const [filter, setFilter] = useState('');

  // í•¨ìˆ˜ê°€ ë§¤ë²ˆ ìƒˆë¡œ ìƒì„±ë˜ëŠ” ê²ƒì„ ë°©ì§€
  const handleEdit = useCallback((userId) => {
    console.log('Editing user:', userId);
    // í¸ì§‘ ë¡œì§
  }, []);

  const handleDelete = useCallback((userId) => {
    setUsers(prev => prev.filter(user => user.id !== userId));
  }, []);

  const filteredUsers = useMemo(() => {
    return users.filter(user => 
      user.name.toLowerCase().includes(filter.toLowerCase())
    );
  }, [users, filter]);

  return (
    <div>
      <input 
        value={filter}
        onChange={(e) => setFilter(e.target.value)}
        placeholder="Filter users..."
      />
      {filteredUsers.map(user => (
        <UserCard 
          key={user.id} 
          user={user}
          onEdit={handleEdit}
          onDelete={handleDelete}
        />
      ))}
    </div>
  );
};
```

#### 2. Lazy Loadingê³¼ Code Splitting
```javascript
// âœ… React.lazyë¡œ ì»´í¬ë„ŒíŠ¸ ì§€ì—° ë¡œë”©
const UserProfile = React.lazy(() => import('./UserProfile'));
const UserSettings = React.lazy(() => import('./UserSettings'));
const AdminPanel = React.lazy(() => import('./AdminPanel'));

const App = () => {
  return (
    <Router>
      <Suspense fallback={<div>Loading...</div>}>
        <Routes>
          <Route path="/profile" element={<UserProfile />} />
          <Route path="/settings" element={<UserSettings />} />
          <Route path="/admin" element={<AdminPanel />} />
        </Routes>
      </Suspense>
    </Router>
  );
};

// âœ… ë™ì  importë¡œ ì¡°ê±´ë¶€ ë¡œë”©
const UserDashboard = () => {
  const [showChart, setShowChart] = useState(false);
  const [ChartComponent, setChartComponent] = useState(null);

  const loadChart = async () => {
    if (!ChartComponent) {
      const { default: Chart } = await import('./Chart');
      setChartComponent(() => Chart);
    }
    setShowChart(true);
  };

  return (
    <div>
      <button onClick={loadChart}>Show Chart</button>
      {showChart && ChartComponent && <ChartComponent />}
    </div>
  );
};
```

### ìŠ¤íƒ€ì¼ë§ ê°€ì´ë“œ

#### 1. CSS Modules
```javascript
// UserCard.module.css
.card {
  border: 1px solid #ddd;
  border-radius: 8px;
  padding: 16px;
  margin: 8px 0;
  background: white;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.card:hover {
  box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}

.title {
  font-size: 1.2rem;
  font-weight: bold;
  margin-bottom: 8px;
  color: #333;
}

.email {
  color: #666;
  font-size: 0.9rem;
}

.actions {
  margin-top: 12px;
  display: flex;
  gap: 8px;
}

.button {
  padding: 6px 12px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.8rem;
}

.editButton {
  background: #007bff;
  color: white;
}

.deleteButton {
  background: #dc3545;
  color: white;
}

// UserCard.jsx
import styles from './UserCard.module.css';

const UserCard = ({ user, onEdit, onDelete }) => {
  return (
    <div className={styles.card}>
      <h3 className={styles.title}>{user.name}</h3>
      <p className={styles.email}>{user.email}</p>
      <div className={styles.actions}>
        <button 
          className={`${styles.button} ${styles.editButton}`}
          onClick={() => onEdit(user.id)}
        >
          Edit
        </button>
        <button 
          className={`${styles.button} ${styles.deleteButton}`}
          onClick={() => onDelete(user.id)}
        >
          Delete
        </button>
      </div>
    </div>
  );
};
```

#### 2. Styled Components
```javascript
import styled from 'styled-components';

// âœ… ê¸°ë³¸ ìŠ¤íƒ€ì¼ ì»´í¬ë„ŒíŠ¸
const Card = styled.div`
  border: 1px solid #ddd;
  border-radius: 8px;
  padding: 16px;
  margin: 8px 0;
  background: white;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  transition: box-shadow 0.2s ease;

  &:hover {
    box-shadow: 0 4px 8px rgba(0,0,0,0.15);
  }
`;

const Title = styled.h3`
  font-size: 1.2rem;
  font-weight: bold;
  margin-bottom: 8px;
  color: #333;
`;

const Email = styled.p`
  color: #666;
  font-size: 0.9rem;
  margin: 0;
`;

const Actions = styled.div`
  margin-top: 12px;
  display: flex;
  gap: 8px;
`;

// âœ… Props ê¸°ë°˜ ìŠ¤íƒ€ì¼ë§
const Button = styled.button`
  padding: 6px 12px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.8rem;
  transition: opacity 0.2s ease;

  &:hover {
    opacity: 0.8;
  }

  ${props => props.variant === 'primary' && `
    background: #007bff;
    color: white;
  `}

  ${props => props.variant === 'danger' && `
    background: #dc3545;
    color: white;
  `}
`;

// ì‚¬ìš©
const UserCard = ({ user, onEdit, onDelete }) => {
  return (
    <div className={styles.card}>
      <h3 className={styles.title}>{user.name}</h3>
      <p className={styles.email}>{user.email}</p>
      <div className={styles.actions}>
        <button 
          className={`${styles.button} ${styles.editButton}`}
          onClick={() => onEdit(user.id)}
        >
          Edit
        </button>
        <button 
          className={`${styles.button} ${styles.deleteButton}`}
          onClick={() => onDelete(user.id)}
        >
          Delete
        </button>
      </div>
    </div>
  );
};
```

### API í†µì‹  íŒ¨í„´

#### 1. Axios ê¸°ë°˜ API í´ë¼ì´ì–¸íŠ¸
```javascript
// api/client.js
import axios from 'axios';

const API_BASE_URL = process.env.REACT_APP_API_BASE_URL || 'http://localhost:8080';

const apiClient = axios.create({
  baseURL: API_BASE_URL,
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json'
  }
});

// ìš”ì²­ ì¸í„°ì…‰í„°
apiClient.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('authToken');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// ì‘ë‹µ ì¸í„°ì…‰í„°
apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      localStorage.removeItem('authToken');
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

export default apiClient;

// api/userApi.js
import apiClient from './client';

export const userApi = {
  getUsers: (params = {}) => {
    return apiClient.get('/api/v1/users', { params });
  },

  getUser: (id) => {
    return apiClient.get(`/api/v1/users/${id}`);
  },

  createUser: (userData) => {
    return apiClient.post('/api/v1/users', userData);
  },

  updateUser: (id, userData) => {
    return apiClient.put(`/api/v1/users/${id}`, userData);
  },

  deleteUser: (id) => {
    return apiClient.delete(`/api/v1/users/${id}`);
  }
};
```

#### 2. React Query ì‚¬ìš© (ê¶Œì¥)
```javascript
// hooks/useUsers.js
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { userApi } from '../api/userApi';

export const useUsers = (params = {}) => {
  return useQuery({
    queryKey: ['users', params],
    queryFn: () => userApi.getUsers(params),
    select: (response) => response.data,
    staleTime: 5 * 60 * 1000, // 5ë¶„
    cacheTime: 10 * 60 * 1000, // 10ë¶„
  });
};

export const useUser = (id) => {
  return useQuery({
    queryKey: ['user', id],
    queryFn: () => userApi.getUser(id),
    select: (response) => response.data,
    enabled: !!id, // idê°€ ìˆì„ ë•Œë§Œ ì‹¤í–‰
  });
};

export const useCreateUser = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: userApi.createUser,
    onSuccess: () => {
      // ì‚¬ìš©ì ëª©ë¡ ìºì‹œ ë¬´íš¨í™”
      queryClient.invalidateQueries({ queryKey: ['users'] });
    },
    onError: (error) => {
      console.error('Failed to create user:', error);
    }
  });
};

export const useUpdateUser = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, ...data }) => userApi.updateUser(id, data),
    onSuccess: (_, variables) => {
      // íŠ¹ì • ì‚¬ìš©ì ìºì‹œ ë¬´íš¨í™”
      queryClient.invalidateQueries({ queryKey: ['user', variables.id] });
      queryClient.invalidateQueries({ queryKey: ['users'] });
    }
  });
};

// ì»´í¬ë„ŒíŠ¸ì—ì„œ ì‚¬ìš©
const UserList = () => {
  const { data: users, isLoading, error } = useUsers();
  const createUserMutation = useCreateUser();

  const handleCreateUser = async (userData) => {
    try {
      await createUserMutation.mutateAsync(userData);
      // ì„±ê³µ ë©”ì‹œì§€ í‘œì‹œ
    } catch (error) {
      // ì—ëŸ¬ ë©”ì‹œì§€ í‘œì‹œ
    }
  };

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      {users?.map(user => (
        <UserCard key={user.id} user={user} />
      ))}
    </div>
  );
};
```

### ì—ëŸ¬ ì²˜ë¦¬ íŒ¨í„´

#### 1. Error Boundary
```javascript
// components/ErrorBoundary.jsx
class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
    // ì—ëŸ¬ ë¡œê¹… ì„œë¹„ìŠ¤ë¡œ ì „ì†¡
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="error-boundary">
          <h2>Something went wrong.</h2>
          <details>
            {this.state.error && this.state.error.toString()}
          </details>
          <button onClick={() => window.location.reload()}>
            Reload Page
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}

// App.jsxì—ì„œ ì‚¬ìš©
const App = () => {
  return (
    <ErrorBoundary>
      <Router>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/users" element={<UserList />} />
        </Routes>
      </Router>
    </ErrorBoundary>
  );
};
```

#### 2. ê¸€ë¡œë²Œ ì—ëŸ¬ ì²˜ë¦¬
```javascript
// context/ErrorContext.jsx
const ErrorContext = createContext();

export const ErrorProvider = ({ children }) => {
  const [errors, setErrors] = useState([]);

  const addError = (error) => {
    const errorId = Date.now();
    setErrors(prev => [...prev, { id: errorId, message: error.message }]);
    
    // 5ì´ˆ í›„ ìë™ ì œê±°
    setTimeout(() => {
      removeError(errorId);
    }, 5000);
  };

  const removeError = (id) => {
    setErrors(prev => prev.filter(error => error.id !== id));
  };

  return (
    <ErrorContext.Provider value={{ errors, addError, removeError }}>
      {children}
    </ErrorContext.Provider>
  );
};

// components/ErrorToast.jsx
const ErrorToast = ({ errors, onRemove }) => {
  return (
    <div className="error-toast-container">
      {errors.map(error => (
        <div key={error.id} className="error-toast">
          <span>{error.message}</span>
          <button onClick={() => onRemove(error.id)}>Ã—</button>
        </div>
      ))}
    </div>
  );
};
```

### í…ŒìŠ¤íŠ¸ ì‘ì„± ê°€ì´ë“œ

#### 1. ì»´í¬ë„ŒíŠ¸ í…ŒìŠ¤íŠ¸ (React Testing Library)
```javascript
// UserCard.test.jsx
import { render, screen, fireEvent } from '@testing-library/react';
import { UserCard } from './UserCard';

const mockUser = {
  id: 1,
  name: 'John Doe',
  email: 'john@example.com'
};

describe('UserCard', () => {
  it('renders user information correctly', () => {
    render(
      <UserCard 
        user={mockUser} 
        onEdit={() => {}} 
        onDelete={() => {}} 
      />
    );

    expect(screen.getByText('John Doe')).toBeInTheDocument();
    expect(screen.getByText('john@example.com')).toBeInTheDocument();
  });

  it('calls onEdit when edit button is clicked', () => {
    const onEdit = jest.fn();
    
    render(
      <UserCard 
        user={mockUser} 
        onEdit={onEdit} 
        onDelete={() => {}} 
      />
    );

    fireEvent.click(screen.getByText('Edit'));
    expect(onEdit).toHaveBeenCalledWith(1);
  });

  it('calls onDelete when delete button is clicked', () => {
    const onDelete = jest.fn();
    
    render(
      <UserCard 
        user={mockUser} 
        onEdit={() => {}} 
        onDelete={onDelete} 
      />
    );

    fireEvent.click(screen.getByText('Delete'));
    expect(onDelete).toHaveBeenCalledWith(1);
  });
});
```

#### 2. ì»¤ìŠ¤í…€ Hook í…ŒìŠ¤íŠ¸
```javascript
// useUsers.test.js
import { renderHook, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { useUsers } from './useUsers';
import { userApi } from '../api/userApi';

jest.mock('../api/userApi');

const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false },
    },
  });

  return ({ children }) => (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );
};

describe('useUsers', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('fetches users successfully', async () => {
    const mockUsers = [
      { id: 1, name: 'John Doe', email: 'john@example.com' }
    ];
    
    userApi.getUsers.mockResolvedValue({ data: mockUsers });

    const { result } = renderHook(() => useUsers(), {
      wrapper: createWrapper(),
    });

    await waitFor(() => {
      expect(result.current.isSuccess).toBe(true);
    });

    expect(result.current.data).toEqual(mockUsers);
  });

  it('handles error correctly', async () => {
    userApi.getUsers.mockRejectedValue(new Error('API Error'));

    const { result } = renderHook(() => useUsers(), {
      wrapper: createWrapper(),
    });

    await waitFor(() => {
      expect(result.current.isError).toBe(true);
    });

    expect(result.current.error.message).toBe('API Error');
  });
});
```

### ì‹¤ë¬´ íŒ ë° ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤

#### 1. í´ë” êµ¬ì¡° ê¶Œì¥ì•ˆ
```
src/
â”œâ”€â”€ components/          # ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ì»´í¬ë„ŒíŠ¸
â”‚   â”œâ”€â”€ ui/             # ê¸°ë³¸ UI ì»´í¬ë„ŒíŠ¸ (Button, Input ë“±)
â”‚   â”œâ”€â”€ layout/         # ë ˆì´ì•„ì›ƒ ì»´í¬ë„ŒíŠ¸
â”‚   â””â”€â”€ common/         # ê³µí†µ ì»´í¬ë„ŒíŠ¸
â”œâ”€â”€ pages/              # í˜ì´ì§€ ì»´í¬ë„ŒíŠ¸
â”œâ”€â”€ hooks/              # ì»¤ìŠ¤í…€ Hook
â”œâ”€â”€ context/            # Context ì œê³µì
â”œâ”€â”€ api/                # API ê´€ë ¨
â”œâ”€â”€ utils/              # ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
â”œâ”€â”€ constants/          # ìƒìˆ˜
â”œâ”€â”€ styles/             # ê¸€ë¡œë²Œ ìŠ¤íƒ€ì¼
â””â”€â”€ __tests__/          # í…ŒìŠ¤íŠ¸ íŒŒì¼
```

#### 2. í™˜ê²½ ë³€ìˆ˜ ê´€ë¦¬
```javascript
// .env.development
REACT_APP_API_BASE_URL=http://localhost:8080
REACT_APP_APP_NAME=Dev App

// .env.production
REACT_APP_API_BASE_URL=https://api.example.com
REACT_APP_APP_NAME=Production App

// config/env.js
export const config = {
  apiBaseUrl: process.env.REACT_APP_API_BASE_URL,
  appName: process.env.REACT_APP_APP_NAME,
  isDevelopment: process.env.NODE_ENV === 'development',
  isProduction: process.env.NODE_ENV === 'production',
};
```

#### 3. íƒ€ì… ì•ˆì •ì„± (PropTypes ë˜ëŠ” TypeScript)
```javascript
// TypeScript ì‚¬ìš© ì‹œ (ê¶Œì¥)
interface User {
  id: number;
  name: string;
  email: string;
  avatar?: string;
}

interface UserCardProps {
  user: User;
  onEdit: (id: number) => void;
  onDelete: (id: number) => void;
}

const UserCard: React.FC<UserCardProps> = ({ user, onEdit, onDelete }) => {
  return (
    <div className="user-card">
      <h3>{user.name}</h3>
      <p>{user.email}</p>
      <button onClick={() => onEdit(user.id)}>Edit</button>
      <button onClick={() => onDelete(user.id)}>Delete</button>
    </div>
  );
};
```

## í…ŒìŠ¤íŠ¸ ê°€ì´ë“œë¼ì¸

### í…ŒìŠ¤íŠ¸ ì „ëµ ë° ì¢…ë¥˜

#### í…ŒìŠ¤íŠ¸ í”¼ë¼ë¯¸ë“œ
```
         /\
        /  \
       /E2E \     <- ì†Œìˆ˜ì˜ í•µì‹¬ í”Œë¡œìš°
      /______\
     /        \
    / í†µí•© í…ŒìŠ¤íŠ¸ \   <- ì£¼ìš” ëª¨ë“ˆ ì—°ë™
   /____________\
  /              \
 /    ë‹¨ìœ„ í…ŒìŠ¤íŠ¸    \  <- ëŒ€ë¶€ë¶„ì˜ í…ŒìŠ¤íŠ¸
/__________________\
```

**1. ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ (Unit Tests)**
- **ëª©ì **: ê°œë³„ í•¨ìˆ˜, ë©”ì†Œë“œ, ì»´í¬ë„ŒíŠ¸ì˜ ì •í™•ì„± ê²€ì¦
- **ë¹„ìœ¨**: ì „ì²´ í…ŒìŠ¤íŠ¸ì˜ 70%
- **íŠ¹ì§•**: ë¹ ë¥´ê³ , ë…ë¦½ì ì´ë©°, ë‹¨ìˆœí•¨

**2. í†µí•© í…ŒìŠ¤íŠ¸ (Integration Tests)**
- **ëª©ì **: ì—¬ëŸ¬ ëª¨ë“ˆ/ì»´í¬ë„ŒíŠ¸ ê°„ì˜ ìƒí˜¸ì‘ìš© ê²€ì¦
- **ë¹„ìœ¨**: ì „ì²´ í…ŒìŠ¤íŠ¸ì˜ 20%
- **íŠ¹ì§•**: ì‹¤ì œ ë°ì´í„°ë² ì´ìŠ¤ë‚˜ APIì™€ì˜ ì—°ë™ í…ŒìŠ¤íŠ¸

**3. E2E í…ŒìŠ¤íŠ¸ (End-to-End Tests)**
- **ëª©ì **: ì‚¬ìš©ì ê´€ì ì—ì„œ ì „ì²´ ì• í”Œë¦¬ì¼€ì´ì…˜ í”Œë¡œìš° ê²€ì¦
- **ë¹„ìœ¨**: ì „ì²´ í…ŒìŠ¤íŠ¸ì˜ 10%
- **íŠ¹ì§•**: ì‹¤ì œ ë¸Œë¼ìš°ì € í™˜ê²½ì—ì„œ í…ŒìŠ¤íŠ¸

### ë°±ì—”ë“œ í…ŒìŠ¤íŠ¸ ìƒì„¸ ê°€ì´ë“œ

#### 1. í…ŒìŠ¤íŠ¸ í™˜ê²½ ì„¤ì •

**build.gradle.kts ì„¤ì •**
```kotlin
dependencies {
    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("org.springframework.boot:spring-boot-testcontainers")
    testImplementation("org.testcontainers:junit-jupiter")
    testImplementation("org.testcontainers:postgresql")
    testImplementation("io.mockk:mockk:1.13.8")
    testImplementation("com.ninja-squad:springmockk:4.0.2")
}
```

**application-test.yml**
```yaml
spring:
  datasource:
    url: jdbc:h2:mem:testdb
    driver-class-name: org.h2.Driver
    username: sa
    password:
  jpa:
    hibernate:
      ddl-auto: create-drop
    show-sql: true
  profiles:
    active: test

logging:
  level:
    com.company: DEBUG
    org.springframework.web: DEBUG
```

#### 2. ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‘ì„±

**ë„ë©”ì¸ ì—”í‹°í‹° í…ŒìŠ¤íŠ¸**
```kotlin
// UserTest.kt
@DisplayName("User ì—”í‹°í‹° í…ŒìŠ¤íŠ¸")
class UserTest {
    
    @Test
    @DisplayName("ì‚¬ìš©ì ìƒì„± - ì„±ê³µ")
    fun `should create user with valid data`() {
        // Given
        val email = Email("test@example.com")
        val name = "í™ê¸¸ë™"
        
        // When
        val user = User.create(name, email)
        
        // Then
        assertThat(user.name).isEqualTo(name)
        assertThat(user.email).isEqualTo(email)
        assertThat(user.status).isEqualTo(UserStatus.ACTIVE)
        assertThat(user.flagActive()).isTrue()
    }
    
    @Test
    @DisplayName("ì‚¬ìš©ì ìƒì„± - ë¹ˆ ì´ë¦„ìœ¼ë¡œ ì‹¤íŒ¨")
    fun `should fail to create user with empty name`() {
        // Given
        val email = Email("test@example.com")
        val emptyName = ""
        
        // When & Then
        assertThatThrownBy {
            User.create(emptyName, email)
        }.isInstanceOf(IllegalArgumentException::class.java)
         .hasMessage("Name cannot be blank")
    }
    
    @Test
    @DisplayName("ì‚¬ìš©ì ìƒíƒœ ë³€ê²½")
    fun `should change user status`() {
        // Given
        val user = User.create("í™ê¸¸ë™", Email("test@example.com"))
        
        // When
        user.deactivate()
        
        // Then
        assertThat(user.status).isEqualTo(UserStatus.INACTIVE)
        assertThat(user.flagActive()).isFalse()
    }
}
```

**ë„ë©”ì¸ ì„œë¹„ìŠ¤ í…ŒìŠ¤íŠ¸**
```kotlin
// UserDomainServiceTest.kt
@ExtendWith(MockKExtension::class)
@DisplayName("User ë„ë©”ì¸ ì„œë¹„ìŠ¤ í…ŒìŠ¤íŠ¸")
class UserDomainServiceTest {
    
    @MockK
    private lateinit var userRepository: UserRepository
    
    private lateinit var userDomainService: UserDomainService
    
    @BeforeEach
    fun setUp() {
        userDomainService = UserDomainService(userRepository)
    }
    
    @Test
    @DisplayName("ì´ë©”ì¼ ì¤‘ë³µ ê²€ì¦ - ì¤‘ë³µ ì—†ìŒ")
    fun `should validate email is not duplicated`() {
        // Given
        val email = Email("new@example.com")
        every { userRepository.existsByEmail(email) } returns false
        
        // When
        val result = userDomainService.validateEmailUniqueness(email)
        
        // Then
        assertThat(result).isTrue()
        verify { userRepository.existsByEmail(email) }
    }
    
    @Test
    @DisplayName("ì´ë©”ì¼ ì¤‘ë³µ ê²€ì¦ - ì¤‘ë³µ ì¡´ì¬")
    fun `should throw exception when email is duplicated`() {
        // Given
        val email = Email("existing@example.com")
        every { userRepository.existsByEmail(email) } returns true
        
        // When & Then
        assertThatThrownBy {
            userDomainService.validateEmailUniqueness(email)
        }.isInstanceOf(DuplicateEmailException::class.java)
         .hasMessage("Email already exists: ${email.value}")
    }
}
```

**ì• í”Œë¦¬ì¼€ì´ì…˜ ì„œë¹„ìŠ¤ í…ŒìŠ¤íŠ¸**
```kotlin
// UserApplicationServiceTest.kt
@ExtendWith(MockKExtension::class)
@DisplayName("User ì• í”Œë¦¬ì¼€ì´ì…˜ ì„œë¹„ìŠ¤ í…ŒìŠ¤íŠ¸")
class UserApplicationServiceTest {
    
    @MockK
    private lateinit var userRepository: UserRepository
    
    @MockK
    private lateinit var userDomainService: UserDomainService
    
    private lateinit var userApplicationService: UserApplicationService
    
    @BeforeEach
    fun setUp() {
        userApplicationService = UserApplicationService(
            userRepository, 
            userDomainService
        )
    }
    
    @Test
    @DisplayName("ì‚¬ìš©ì ìƒì„± - ì„±ê³µ")
    fun `should create user successfully`() {
        // Given
        val request = CreateUserRequest("í™ê¸¸ë™", "test@example.com")
        val user = User.create(request.name, Email(request.email))
        
        every { userDomainService.validateEmailUniqueness(any()) } returns true
        every { userRepository.save(any()) } returns user.copy(id = 1L)
        
        // When
        val response = userApplicationService.createUser(request)
        
        // Then
        assertThat(response.id).isEqualTo(1L)
        assertThat(response.name).isEqualTo(request.name)
        assertThat(response.email).isEqualTo(request.email)
        
        verify { userDomainService.validateEmailUniqueness(Email(request.email)) }
        verify { userRepository.save(any()) }
    }
    
    @Test
    @DisplayName("ì‚¬ìš©ì ì¡°íšŒ - ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ì‚¬ìš©ì")
    fun `should throw exception when user not found`() {
        // Given
        val userId = 999L
        every { userRepository.findById(userId) } returns null
        
        // When & Then
        assertThatThrownBy {
            userApplicationService.getUser(userId)
        }.isInstanceOf(UserNotFoundException::class.java)
         .hasMessage("User not found with id: $userId")
    }
}
```

#### 3. í†µí•© í…ŒìŠ¤íŠ¸ ì‘ì„±

**Repository í†µí•© í…ŒìŠ¤íŠ¸**
```kotlin
// UserRepositoryIntegrationTest.kt
@DataJpaTest
@TestPropertySource(properties = ["spring.jpa.hibernate.ddl-auto=create-drop"])
@DisplayName("User Repository í†µí•© í…ŒìŠ¤íŠ¸")
class UserRepositoryIntegrationTest @Autowired constructor(
    private val userRepository: UserRepository,
    private val testEntityManager: TestEntityManager
) {
    
    @Test
    @DisplayName("ì´ë©”ì¼ë¡œ ì‚¬ìš©ì ì¡°íšŒ")
    fun `should find user by email`() {
        // Given
        val user = User.create("í™ê¸¸ë™", Email("test@example.com"))
        testEntityManager.persistAndFlush(user)
        
        // When
        val foundUser = userRepository.findByEmail(Email("test@example.com"))
        
        // Then
        assertThat(foundUser).isNotNull
        assertThat(foundUser?.name).isEqualTo("í™ê¸¸ë™")
        assertThat(foundUser?.email?.value).isEqualTo("test@example.com")
    }
    
    @Test
    @DisplayName("í™œì„± ì‚¬ìš©ì ëª©ë¡ ì¡°íšŒ")
    fun `should find only active users`() {
        // Given
        val activeUser1 = User.create("í™ê¸¸ë™", Email("active1@example.com"))
        val activeUser2 = User.create("ê¹€ì² ìˆ˜", Email("active2@example.com"))
        val inactiveUser = User.create("ì´ì˜í¬", Email("inactive@example.com"))
        inactiveUser.deactivate()
        
        testEntityManager.persistAndFlush(activeUser1)
        testEntityManager.persistAndFlush(activeUser2)
        testEntityManager.persistAndFlush(inactiveUser)
        
        // When
        val activeUsers = userRepository.findByStatus(UserStatus.ACTIVE)
        
        // Then
        assertThat(activeUsers).hasSize(2)
        assertThat(activeUsers.map { it.name }).containsExactlyInAnyOrder("í™ê¸¸ë™", "ê¹€ì² ìˆ˜")
    }
}
```

**Controller í†µí•© í…ŒìŠ¤íŠ¸**
```kotlin
// UserControllerIntegrationTest.kt
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@TestPropertySource(properties = ["spring.profiles.active=test"])
@Transactional
@DisplayName("User Controller í†µí•© í…ŒìŠ¤íŠ¸")
class UserControllerIntegrationTest @Autowired constructor(
    private val restTemplate: TestRestTemplate,
    private val userRepository: UserRepository
) {
    
    @Test
    @DisplayName("ì‚¬ìš©ì ìƒì„± API - ì„±ê³µ")
    fun `should create user via API`() {
        // Given
        val request = CreateUserRequest("í™ê¸¸ë™", "test@example.com")
        val entity = HttpEntity(request)
        
        // When
        val response = restTemplate.postForEntity(
            "/api/v1/users", 
            entity, 
            ApiResponse::class.java
        )
        
        // Then
        assertThat(response.statusCode).isEqualTo(HttpStatus.CREATED)
        
        val savedUser = userRepository.findByEmail(Email("test@example.com"))
        assertThat(savedUser).isNotNull
        assertThat(savedUser?.name).isEqualTo("í™ê¸¸ë™")
    }
    
    @Test
    @DisplayName("ì‚¬ìš©ì ëª©ë¡ ì¡°íšŒ API - í˜ì´ì§•")
    fun `should get users with pagination`() {
        // Given
        repeat(25) { i ->
            val user = User.create("ì‚¬ìš©ì$i", Email("user$i@example.com"))
            userRepository.save(user)
        }
        
        // When
        val response = restTemplate.getForEntity(
            "/api/v1/users?page=0&size=10", 
            String::class.java
        )
        
        // Then
        assertThat(response.statusCode).isEqualTo(HttpStatus.OK)
        // JSON ì‘ë‹µ ê²€ì¦ ë¡œì§ ì¶”ê°€
    }
}
```

#### 4. í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ë° ì»¤ë²„ë¦¬ì§€

**í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ëª…ë ¹ì–´**
```bash
# ëª¨ë“  í…ŒìŠ¤íŠ¸ ì‹¤í–‰
./gradlew test

# íŠ¹ì • í…ŒìŠ¤íŠ¸ í´ë˜ìŠ¤ ì‹¤í–‰
./gradlew test --tests "*UserServiceTest"

# íŠ¹ì • íŒ¨í‚¤ì§€ì˜ í…ŒìŠ¤íŠ¸ ì‹¤í–‰
./gradlew test --tests "com.company.user.*"

# í…ŒìŠ¤íŠ¸ ê²°ê³¼ë¥¼ ìƒì„¸íˆ ë³´ê¸°
./gradlew test --info

# ë³‘ë ¬ í…ŒìŠ¤íŠ¸ ì‹¤í–‰ (ì„±ëŠ¥ í–¥ìƒ)
./gradlew test --parallel

# íŠ¹ì • í…ŒìŠ¤íŠ¸ ë©”ì†Œë“œë§Œ ì‹¤í–‰
./gradlew test --tests "*UserServiceTest.should create user successfully"
```

**ì»¤ë²„ë¦¬ì§€ í™•ì¸**
```bash
# JaCoCo ì»¤ë²„ë¦¬ì§€ ë¦¬í¬íŠ¸ ìƒì„±
./gradlew jacocoTestReport

# ì»¤ë²„ë¦¬ì§€ ê²€ì¦ (ìµœì†Œ 80% ìš”êµ¬)
./gradlew jacocoTestCoverageVerification

# ë¦¬í¬íŠ¸ í™•ì¸ ìœ„ì¹˜
# build/reports/jacoco/test/html/index.html
```

**build.gradle.kts JaCoCo ì„¤ì •**
```kotlin
jacoco {
    toolVersion = "0.8.8"
}

tasks.jacocoTestReport {
    reports {
        xml.required.set(true)
        html.required.set(true)
        csv.required.set(false)
    }
    finalizedBy(tasks.jacocoTestCoverageVerification)
}

tasks.jacocoTestCoverageVerification {
    violationRules {
        rule {
            limit {
                minimum = "0.80".toBigDecimal() // 80% ì»¤ë²„ë¦¬ì§€ ìš”êµ¬
            }
        }
        rule {
            element = "CLASS"
            excludes = listOf("*.config.*", "*.dto.*")
            limit {
                counter = "LINE"
                value = "COVEREDRATIO"
                minimum = "0.80".toBigDecimal()
            }
        }
    }
}
```

### í”„ë¡ íŠ¸ì—”ë“œ í…ŒìŠ¤íŠ¸ ìƒì„¸ ê°€ì´ë“œ

#### 1. í…ŒìŠ¤íŠ¸ í™˜ê²½ ì„¤ì •

**package.json ì„¤ì •**
```json
{
  "devDependencies": {
    "@testing-library/react": "^13.4.0",
    "@testing-library/jest-dom": "^5.16.5",
    "@testing-library/user-event": "^14.4.3",
    "jest": "^27.5.1",
    "jest-environment-jsdom": "^27.5.1",
    "msw": "^0.49.3"
  },
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage",
    "test:ci": "jest --coverage --watchAll=false"
  }
}
```

**jest.config.js**
```javascript
module.exports = {
  testEnvironment: 'jsdom',
  setupFilesAfterEnv: ['<rootDir>/src/setupTests.js'],
  moduleNameMapping: {
    '\\.(css|less|scss|sass)$': 'identity-obj-proxy',
    '^@/(.*)$': '<rootDir>/src/$1'
  },
  collectCoverageFrom: [
    'src/**/*.{js,jsx}',
    '!src/index.js',
    '!src/reportWebVitals.js',
    '!src/**/*.stories.js'
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  }
};
```

**src/setupTests.js**
```javascript
import '@testing-library/jest-dom';
import { server } from './mocks/server';

// MSW ì„œë²„ ì„¤ì •
beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());
```

#### 2. ì»´í¬ë„ŒíŠ¸ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸

**ê¸°ë³¸ ì»´í¬ë„ŒíŠ¸ í…ŒìŠ¤íŠ¸**
```javascript
// UserCard.test.jsx
import { render, screen, fireEvent } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { UserCard } from './UserCard';

const mockUser = {
  id: 1,
  name: 'John Doe',
  email: 'john@example.com',
  status: 'ACTIVE'
};

describe('UserCard', () => {
  test('ì‚¬ìš©ì ì •ë³´ë¥¼ ì˜¬ë°”ë¥´ê²Œ ë Œë”ë§í•œë‹¤', () => {
    // Given
    const onEdit = jest.fn();
    const onDelete = jest.fn();
    
    // When
    render(
      <UserCard 
        user={mockUser} 
        onEdit={onEdit} 
        onDelete={onDelete} 
      />
    );
    
    // Then
    expect(screen.getByText('John Doe')).toBeInTheDocument();
    expect(screen.getByText('john@example.com')).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /edit/i })).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /delete/i })).toBeInTheDocument();
  });
  
  test('í¸ì§‘ ë²„íŠ¼ í´ë¦­ ì‹œ onEdit ì½œë°±ì´ í˜¸ì¶œëœë‹¤', async () => {
    // Given
    const user = userEvent.setup();
    const onEdit = jest.fn();
    const onDelete = jest.fn();
    
    render(
      <UserCard 
        user={mockUser} 
        onEdit={onEdit} 
        onDelete={onDelete} 
      />
    );
    
    // When
    await user.click(screen.getByRole('button', { name: /edit/i }));
    
    // Then
    expect(onEdit).toHaveBeenCalledTimes(1);
    expect(onEdit).toHaveBeenCalledWith(1);
  });
  
  test('ì‚­ì œ ë²„íŠ¼ í´ë¦­ ì‹œ onDelete ì½œë°±ì´ í˜¸ì¶œëœë‹¤', async () => {
    // Given
    const user = userEvent.setup();
    const onEdit = jest.fn();
    const onDelete = jest.fn();
    
    render(
      <UserCard 
        user={mockUser} 
        onEdit={onEdit} 
        onDelete={onDelete} 
      />
    );
    
    // When
    await user.click(screen.getByRole('button', { name: /delete/i }));
    
    // Then
    expect(onDelete).toHaveBeenCalledTimes(1);
    expect(onDelete).toHaveBeenCalledWith(1);
  });
  
  test('ë¹„í™œì„± ì‚¬ìš©ìì˜ ê²½ìš° ìƒíƒœê°€ í‘œì‹œëœë‹¤', () => {
    // Given
    const inactiveUser = { ...mockUser, status: 'INACTIVE' };
    
    // When
    render(
      <UserCard 
        user={inactiveUser} 
        onEdit={() => {}} 
        onDelete={() => {}} 
      />
    );
    
    // Then
    expect(screen.getByText(/inactive/i)).toBeInTheDocument();
  });
});
```

**í¼ ì»´í¬ë„ŒíŠ¸ í…ŒìŠ¤íŠ¸**
```javascript
// UserForm.test.jsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { UserForm } from './UserForm';

describe('UserForm', () => {
  test('í¼ ì œì¶œ ì‹œ ì˜¬ë°”ë¥¸ ë°ì´í„°ê°€ ì „ë‹¬ëœë‹¤', async () => {
    // Given
    const user = userEvent.setup();
    const onSubmit = jest.fn();
    
    render(<UserForm onSubmit={onSubmit} />);
    
    // When
    await user.type(screen.getByLabelText(/name/i), 'John Doe');
    await user.type(screen.getByLabelText(/email/i), 'john@example.com');
    await user.click(screen.getByRole('button', { name: /submit/i }));
    
    // Then
    await waitFor(() => {
      expect(onSubmit).toHaveBeenCalledWith({
        name: 'John Doe',
        email: 'john@example.com'
      });
    });
  });
  
  test('í•„ìˆ˜ í•„ë“œ ëˆ„ë½ ì‹œ ì—ëŸ¬ ë©”ì‹œì§€ê°€ í‘œì‹œëœë‹¤', async () => {
    // Given
    const user = userEvent.setup();
    const onSubmit = jest.fn();
    
    render(<UserForm onSubmit={onSubmit} />);
    
    // When
    await user.click(screen.getByRole('button', { name: /submit/i }));
    
    // Then
    expect(screen.getByText(/name is required/i)).toBeInTheDocument();
    expect(screen.getByText(/email is required/i)).toBeInTheDocument();
    expect(onSubmit).not.toHaveBeenCalled();
  });
  
  test('ì˜ëª»ëœ ì´ë©”ì¼ í˜•ì‹ ì‹œ ì—ëŸ¬ ë©”ì‹œì§€ê°€ í‘œì‹œëœë‹¤', async () => {
    // Given
    const user = userEvent.setup();
    const onSubmit = jest.fn();
    
    render(<UserForm onSubmit={onSubmit} />);
    
    // When
    await user.type(screen.getByLabelText(/name/i), 'John Doe');
    await user.type(screen.getByLabelText(/email/i), 'invalid-email');
    await user.click(screen.getByRole('button', { name: /submit/i }));
    
    // Then
    expect(screen.getByText(/invalid email format/i)).toBeInTheDocument();
    expect(onSubmit).not.toHaveBeenCalled();
  });
});
```

#### 3. ì»¤ìŠ¤í…€ Hook í…ŒìŠ¤íŠ¸

```javascript
// useUsers.test.js
import { renderHook, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { rest } from 'msw';
import { server } from '../mocks/server';
import { useUsers, useCreateUser } from './useUsers';

const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false },
    },
  });

  return ({ children }) => (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );
};

describe('useUsers', () => {
  test('ì‚¬ìš©ì ëª©ë¡ì„ ì„±ê³µì ìœ¼ë¡œ ê°€ì ¸ì˜¨ë‹¤', async () => {
    // Given
    const mockUsers = [
      { id: 1, name: 'John Doe', email: 'john@example.com' },
      { id: 2, name: 'Jane Smith', email: 'jane@example.com' }
    ];
    
    server.use(
      rest.get('/api/v1/users', (req, res, ctx) => {
        return res(ctx.json({ data: mockUsers }));
      })
    );

    // When
    const { result } = renderHook(() => useUsers(), {
      wrapper: createWrapper(),
    });

    // Then
    await waitFor(() => {
      expect(result.current.isSuccess).toBe(true);
    });

    expect(result.current.data).toEqual(mockUsers);
  });

  test('API ì—ëŸ¬ ì‹œ ì—ëŸ¬ ìƒíƒœë¥¼ ë°˜í™˜í•œë‹¤', async () => {
    // Given
    server.use(
      rest.get('/api/v1/users', (req, res, ctx) => {
        return res(ctx.status(500), ctx.json({ message: 'Server Error' }));
      })
    );

    // When
    const { result } = renderHook(() => useUsers(), {
      wrapper: createWrapper(),
    });

    // Then
    await waitFor(() => {
      expect(result.current.isError).toBe(true);
    });

    expect(result.current.error).toBeDefined();
  });
});

describe('useCreateUser', () => {
  test('ì‚¬ìš©ìë¥¼ ì„±ê³µì ìœ¼ë¡œ ìƒì„±í•œë‹¤', async () => {
    // Given
    const newUser = { name: 'New User', email: 'new@example.com' };
    const createdUser = { id: 3, ...newUser };
    
    server.use(
      rest.post('/api/v1/users', (req, res, ctx) => {
        return res(ctx.status(201), ctx.json(createdUser));
      })
    );

    // When
    const { result } = renderHook(() => useCreateUser(), {
      wrapper: createWrapper(),
    });

    // Then
    await waitFor(() => {
      result.current.mutate(newUser);
    });

    await waitFor(() => {
      expect(result.current.isSuccess).toBe(true);
    });

    expect(result.current.data).toEqual(createdUser);
  });
});
```

#### 4. í†µí•© í…ŒìŠ¤íŠ¸ (í˜ì´ì§€ ë‹¨ìœ„)

```javascript
// UserListPage.test.jsx
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { rest } from 'msw';
import { server } from '../mocks/server';
import { UserListPage } from './UserListPage';

const renderWithProviders = (component) => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false },
    },
  });

  return render(
    <QueryClientProvider client={queryClient}>
      {component}
    </QueryClientProvider>
  );
};

describe('UserListPage', () => {
  test('ì‚¬ìš©ì ëª©ë¡ í˜ì´ì§€ê°€ ì •ìƒì ìœ¼ë¡œ ë Œë”ë§ëœë‹¤', async () => {
    // Given
    const mockUsers = [
      { id: 1, name: 'John Doe', email: 'john@example.com' },
      { id: 2, name: 'Jane Smith', email: 'jane@example.com' }
    ];
    
    server.use(
      rest.get('/api/v1/users', (req, res, ctx) => {
        return res(ctx.json({ data: mockUsers }));
      })
    );

    // When
    renderWithProviders(<UserListPage />);

    // Then
    expect(screen.getByText(/loading/i)).toBeInTheDocument();
    
    await waitFor(() => {
      expect(screen.getByText('John Doe')).toBeInTheDocument();
      expect(screen.getByText('Jane Smith')).toBeInTheDocument();
    });
    
    expect(screen.getByText(/user list/i)).toBeInTheDocument();
  });
  
  test('ìƒˆ ì‚¬ìš©ì ì¶”ê°€ í”Œë¡œìš°ê°€ ì •ìƒ ë™ì‘í•œë‹¤', async () => {
    // Given
    const user = userEvent.setup();
    const mockUsers = [];
    const newUser = { id: 1, name: 'New User', email: 'new@example.com' };
    
    server.use(
      rest.get('/api/v1/users', (req, res, ctx) => {
        return res(ctx.json({ data: mockUsers }));
      }),
      rest.post('/api/v1/users', (req, res, ctx) => {
        return res(ctx.status(201), ctx.json(newUser));
      })
    );

    renderWithProviders(<UserListPage />);
    
    await waitFor(() => {
      expect(screen.getByText(/no users found/i)).toBeInTheDocument();
    });

    // When
    await user.click(screen.getByRole('button', { name: /add user/i }));
    await user.type(screen.getByLabelText(/name/i), 'New User');
    await user.type(screen.getByLabelText(/email/i), 'new@example.com');
    await user.click(screen.getByRole('button', { name: /save/i }));

    // Then
    await waitFor(() => {
      expect(screen.getByText('New User')).toBeInTheDocument();
    });
  });
});
```

#### 5. í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ë° ê²°ê³¼ í™•ì¸

**í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ëª…ë ¹ì–´**
```bash
# ëª¨ë“  í…ŒìŠ¤íŠ¸ ì‹¤í–‰
npm test

# Watch ëª¨ë“œë¡œ í…ŒìŠ¤íŠ¸ ì‹¤í–‰ (ê°œë°œ ì¤‘)
npm run test:watch

# íŠ¹ì • íŒŒì¼ë§Œ í…ŒìŠ¤íŠ¸
npm test UserCard.test.jsx

# íŠ¹ì • í…ŒìŠ¤íŠ¸ íŒ¨í„´ìœ¼ë¡œ ì‹¤í–‰
npm test -- --testNamePattern="ì‚¬ìš©ì ì •ë³´"

# ì»¤ë²„ë¦¬ì§€ì™€ í•¨ê»˜ í…ŒìŠ¤íŠ¸ ì‹¤í–‰
npm run test:coverage

# CI í™˜ê²½ì—ì„œ í…ŒìŠ¤íŠ¸ ì‹¤í–‰
npm run test:ci
```

**í…ŒìŠ¤íŠ¸ ê²°ê³¼ í•´ì„**
```bash
# ì„±ê³µ ì˜ˆì‹œ
 PASS  src/components/UserCard.test.jsx
  UserCard
    âœ“ ì‚¬ìš©ì ì •ë³´ë¥¼ ì˜¬ë°”ë¥´ê²Œ ë Œë”ë§í•œë‹¤ (25ms)
    âœ“ í¸ì§‘ ë²„íŠ¼ í´ë¦­ ì‹œ onEdit ì½œë°±ì´ í˜¸ì¶œëœë‹¤ (15ms)
    âœ“ ì‚­ì œ ë²„íŠ¼ í´ë¦­ ì‹œ onDelete ì½œë°±ì´ í˜¸ì¶œëœë‹¤ (12ms)

Test Suites: 1 passed, 1 total
Tests:       3 passed, 3 total
Snapshots:   0 total
Time:        2.456s
```

**ì»¤ë²„ë¦¬ì§€ ë¦¬í¬íŠ¸ í™•ì¸**
```bash
# ì»¤ë²„ë¦¬ì§€ ë¦¬í¬íŠ¸ ìœ„ì¹˜
coverage/lcov-report/index.html

# í„°ë¯¸ë„ì—ì„œ ì»¤ë²„ë¦¬ì§€ ìš”ì•½ í™•ì¸
npm run test:coverage

# ê²°ê³¼ ì˜ˆì‹œ
----------------------|---------|----------|---------|---------|
File                  | % Stmts | % Branch | % Funcs | % Lines |
----------------------|---------|----------|---------|---------|
All files             |   88.89 |     87.5 |     100 |   88.24 |
 src/components       |   91.67 |     87.5 |     100 |   90.91 |
  UserCard.jsx        |   91.67 |     87.5 |     100 |   90.91 |
 src/hooks            |   85.71 |       75 |     100 |   85.71 |
  useUsers.js         |   85.71 |       75 |     100 |   85.71 |
----------------------|---------|----------|---------|---------|
```

### í…ŒìŠ¤íŠ¸ ì‘ì„± ê·œì¹™ ë° ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤

#### 1. ëª…ëª… ê·œì¹™
```javascript
// âœ… ì¢‹ì€ ì˜ˆ: í•œêµ­ì–´ë¡œ ëª…í™•í•œ ì˜ë„ í‘œí˜„
describe('UserCard', () => {
  test('ì‚¬ìš©ì ì •ë³´ë¥¼ ì˜¬ë°”ë¥´ê²Œ ë Œë”ë§í•œë‹¤', () => {});
  test('í¸ì§‘ ë²„íŠ¼ í´ë¦­ ì‹œ onEdit ì½œë°±ì´ í˜¸ì¶œëœë‹¤', () => {});
  test('ë¹„í™œì„± ì‚¬ìš©ìì˜ ê²½ìš° ë¹„í™œì„± ìƒíƒœê°€ í‘œì‹œëœë‹¤', () => {});
});

// âŒ ë‚˜ìœ ì˜ˆ: ëª¨í˜¸í•œ í…ŒìŠ¤íŠ¸ ì´ë¦„
describe('UserCard', () => {
  test('test1', () => {});
  test('should work', () => {});
  test('button click', () => {});
});
```

#### 2. AAA íŒ¨í„´ (Arrange, Act, Assert)
```javascript
test('ì‚¬ìš©ì ìƒì„± ì‹œ ì˜¬ë°”ë¥¸ ë°ì´í„°ê°€ ì €ì¥ëœë‹¤', async () => {
  // Arrange (ì¤€ë¹„)
  const userData = { name: 'John', email: 'john@example.com' };
  const mockSave = jest.fn().mockResolvedValue({ id: 1, ...userData });
  
  // Act (ì‹¤í–‰)
  const result = await userService.createUser(userData);
  
  // Assert (ê²€ì¦)
  expect(result.id).toBe(1);
  expect(result.name).toBe('John');
  expect(mockSave).toHaveBeenCalledWith(userData);
});
```

#### 3. í…ŒìŠ¤íŠ¸ ë…ë¦½ì„± ë³´ì¥
```javascript
describe('UserService', () => {
  beforeEach(() => {
    // ê° í…ŒìŠ¤íŠ¸ ì „ì— ìƒíƒœ ì´ˆê¸°í™”
    jest.clearAllMocks();
    localStorage.clear();
  });
  
  afterEach(() => {
    // ê° í…ŒìŠ¤íŠ¸ í›„ ì •ë¦¬
    cleanup();
  });
});
```

#### 4. ì»¤ë²„ë¦¬ì§€ ëª©í‘œ
- **ìµœì†Œ ì»¤ë²„ë¦¬ì§€**: 80%
- **ì¤‘ìš” ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§**: 95% ì´ìƒ
- **ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜**: 100%

#### 5. CI/CD í†µí•©
**.github/workflows/test.yml**
```yaml
name: Tests
on: [push, pull_request]

jobs:
  backend-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
      - name: Run Backend Tests
        run: ./gradlew test jacocoTestReport
      - name: Upload Coverage
        uses: codecov/codecov-action@v3

  frontend-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
      - name: Install Dependencies
        run: npm ci
      - name: Run Frontend Tests
        run: npm run test:ci
      - name: Upload Coverage
        uses: codecov/codecov-action@v3
```

## ë°°í¬ í”„ë¡œì„¸ìŠ¤

### Docker ì»¨í…Œì´ë„ˆí™” ì „ëµ

#### ë©€í‹° ìŠ¤í…Œì´ì§€ ë¹Œë“œ ì•„í‚¤í…ì²˜
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Build Stage   â”‚â”€â”€â”€â–¶â”‚  Runtime Stage  â”‚â”€â”€â”€â–¶â”‚  Production     â”‚
â”‚                 â”‚    â”‚                 â”‚    â”‚  Container      â”‚
â”‚ â€¢ ì˜ì¡´ì„± ì„¤ì¹˜      â”‚    â”‚ â€¢ ìµœì†Œ ëŸ°íƒ€ì„     â”‚     â”‚ â€¢ ìµœì í™”ëœ ì´ë¯¸ì§€   â”‚
â”‚ â€¢ ì½”ë“œ ë¹Œë“œ       â”‚    â”‚ â€¢ ë³´ì•ˆ ê°•í™”       â”‚     â”‚ â€¢ ìë™ ë°°í¬       â”‚
â”‚ â€¢ í…ŒìŠ¤íŠ¸ ì‹¤í–‰      â”‚    â”‚ â€¢ ì„±ëŠ¥ ìµœì í™”     â”‚     â”‚ â€¢ í—¬ìŠ¤ ì²´í¬       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ë°±ì—”ë“œ Dockerfile êµ¬ì„±

#### 1. Spring Boot ì• í”Œë¦¬ì¼€ì´ì…˜ Dockerfile
```dockerfile
# backend/Dockerfile
FROM openjdk:17-jdk-slim as builder

# ì‘ì—… ë””ë ‰í† ë¦¬ ì„¤ì •
WORKDIR /app

# Gradle Wrapperì™€ ì˜ì¡´ì„± íŒŒì¼ ë³µì‚¬ (ìºì‹œ ìµœì í™”)
COPY gradlew .
COPY gradle gradle
COPY build.gradle.kts .
COPY settings.gradle.kts .

# ì˜ì¡´ì„± ë‹¤ìš´ë¡œë“œ (Docker ë ˆì´ì–´ ìºì‹± í™œìš©)
RUN chmod +x ./gradlew
RUN ./gradlew dependencies --no-daemon

# ì†ŒìŠ¤ ì½”ë“œ ë³µì‚¬
COPY src src

# ì• í”Œë¦¬ì¼€ì´ì…˜ ë¹Œë“œ
RUN ./gradlew bootJar --no-daemon

# ëŸ°íƒ€ì„ ìŠ¤í…Œì´ì§€
FROM openjdk:17-jre-slim

# ë³´ì•ˆ ë° ì„±ëŠ¥ì„ ìœ„í•œ ì‚¬ìš©ì ìƒì„±
RUN groupadd -r appgroup && useradd -r -g appgroup appuser

# ì‘ì—… ë””ë ‰í† ë¦¬ ì„¤ì •
WORKDIR /app

# ë¹Œë“œëœ JAR íŒŒì¼ ë³µì‚¬
COPY --from=builder /app/build/libs/*.jar app.jar

# ì‚¬ìš©ì ê¶Œí•œ ì„¤ì •
RUN chown appuser:appgroup app.jar
USER appuser

# í¬íŠ¸ ë…¸ì¶œ
EXPOSE 8080

# í—¬ìŠ¤ ì²´í¬ ì„¤ì •
HEALTHCHECK --interval=30s --timeout=3s --start-period=60s --retries=3 \
    CMD curl -f http://localhost:8080/actuator/health || exit 1

# JVM ìµœì í™” ë° ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹¤í–‰
ENTRYPOINT ["java", \
    "-Djava.security.egd=file:/dev/./urandom", \
    "-XX:+UseG1GC", \
    "-XX:+UseContainerSupport", \
    "-XX:MaxRAMPercentage=75.0", \
    "-Dspring.profiles.active=${SPRING_PROFILES_ACTIVE:prod}", \
    "-jar", "app.jar"]
```

#### 2. í™˜ê²½ë³„ ì„¤ì • íŒŒì¼
```yaml
# backend/src/main/resources/application-prod.yml
spring:
  datasource:
    url: jdbc:postgresql://${DB_HOST:localhost}:${DB_PORT:5432}/${DB_NAME:appdb}
    username: ${DB_USERNAME:app}
    password: ${DB_PASSWORD}
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000

  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: false
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
        format_sql: false

  redis:
    host: ${REDIS_HOST:localhost}
    port: ${REDIS_PORT:6379}
    password: ${REDIS_PASSWORD:}
    timeout: 2000ms

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  endpoint:
    health:
      show-details: when-authorized

logging:
  level:
    com.company: INFO
    org.springframework.security: WARN
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} - %msg%n"
  file:
    name: /app/logs/application.log

server:
  port: 8080
  shutdown: graceful
  tomcat:
    max-threads: 200
    min-spare-threads: 10
```

### í”„ë¡ íŠ¸ì—”ë“œ Dockerfile êµ¬ì„±

#### 1. React.js ì• í”Œë¦¬ì¼€ì´ì…˜ Dockerfile
```dockerfile
# frontend/Dockerfile
FROM node:18-alpine as builder

# ì‘ì—… ë””ë ‰í† ë¦¬ ì„¤ì •
WORKDIR /app

# package.jsonê³¼ package-lock.json ë³µì‚¬ (ìºì‹œ ìµœì í™”)
COPY package*.json ./

# ì˜ì¡´ì„± ì„¤ì¹˜
RUN npm ci --only=production

# ì†ŒìŠ¤ ì½”ë“œ ë³µì‚¬
COPY . .

# ë¹Œë“œ ì¸ìˆ˜ ì„¤ì •
ARG REACT_APP_API_BASE_URL
ARG REACT_APP_ENV

# í™˜ê²½ ë³€ìˆ˜ ì„¤ì •
ENV REACT_APP_API_BASE_URL=$REACT_APP_API_BASE_URL
ENV REACT_APP_ENV=$REACT_APP_ENV

# ì• í”Œë¦¬ì¼€ì´ì…˜ ë¹Œë“œ
RUN npm run build

# Nginx ëŸ°íƒ€ì„ ìŠ¤í…Œì´ì§€
FROM nginx:alpine

# Nginx ì„¤ì • ë³µì‚¬
COPY nginx.conf /etc/nginx/nginx.conf

# ë¹Œë“œëœ ì •ì  íŒŒì¼ ë³µì‚¬
COPY --from=builder /app/build /usr/share/nginx/html

# í¬íŠ¸ ë…¸ì¶œ
EXPOSE 80

# í—¬ìŠ¤ ì²´í¬ ì„¤ì •
HEALTHCHECK --interval=30s --timeout=3s --start-period=10s --retries=3 \
    CMD wget --no-verbose --tries=1 --spider http://localhost/ || exit 1

# Nginx ì‹¤í–‰
CMD ["nginx", "-g", "daemon off;"]
```

#### 2. Nginx ì„¤ì • íŒŒì¼
```nginx
# frontend/nginx.conf
events {
    worker_connections 1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    # ë¡œê·¸ í˜•ì‹ ì„¤ì •
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                   '$status $body_bytes_sent "$http_referer" '
                   '"$http_user_agent" "$http_x_forwarded_for"';

    access_log /var/log/nginx/access.log main;
    error_log /var/log/nginx/error.log warn;

    # ì„±ëŠ¥ ìµœì í™”
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;

    # Gzip ì••ì¶• ì„¤ì •
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types
        text/plain
        text/css
        text/xml
        text/javascript
        application/javascript
        application/xml+rss
        application/json;

    server {
        listen 80;
        server_name localhost;
        root /usr/share/nginx/html;
        index index.html;

        # ë³´ì•ˆ í—¤ë” ì„¤ì •
        add_header X-Frame-Options "SAMEORIGIN" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header X-XSS-Protection "1; mode=block" always;
        add_header Referrer-Policy "strict-origin-when-cross-origin" always;

        # React Router ì§€ì›ì„ ìœ„í•œ ì„¤ì •
        location / {
            try_files $uri $uri/ /index.html;
        }

        # ì •ì  ìì‚° ìºì‹œ ì„¤ì •
        location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
            expires 1y;
            add_header Cache-Control "public, immutable";
        }

        # API í”„ë¡ì‹œ ì„¤ì •
        location /api/ {
            proxy_pass http://backend:8080;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # í—¬ìŠ¤ ì²´í¬ ì—”ë“œí¬ì¸íŠ¸
        location /health {
            access_log off;
            return 200 "healthy\n";
            add_header Content-Type text/plain;
        }
    }
}
```

### Docker Compose êµ¬ì„±

#### 1. ê°œë°œ í™˜ê²½ (docker-compose.dev.yml)
```yaml
version: '3.8'

services:
  # ë°ì´í„°ë² ì´ìŠ¤
  postgres:
    image: postgres:15-alpine
    container_name: app-postgres-dev
    environment:
      POSTGRES_DB: appdb_dev
      POSTGRES_USER: app_dev
      POSTGRES_PASSWORD: dev_password
    ports:
      - "5432:5432"
    volumes:
      - postgres_dev_data:/var/lib/postgresql/data
      - ./database/init.sql:/docker-entrypoint-initdb.d/init.sql
    networks:
      - app-network

  # Redis
  redis:
    image: redis:7-alpine
    container_name: app-redis-dev
    ports:
      - "6379:6379"
    volumes:
      - redis_dev_data:/data
    networks:
      - app-network

  # ë°±ì—”ë“œ
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: app-backend-dev
    environment:
      SPRING_PROFILES_ACTIVE: dev
      DB_HOST: postgres
      DB_PORT: 5432
      DB_NAME: appdb_dev
      DB_USERNAME: app_dev
      DB_PASSWORD: dev_password
      REDIS_HOST: redis
      REDIS_PORT: 6379
    ports:
      - "8080:8080"
    depends_on:
      - postgres
      - redis
    volumes:
      - ./backend/logs:/app/logs
    networks:
      - app-network
    restart: unless-stopped

  # í”„ë¡ íŠ¸ì—”ë“œ
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      args:
        REACT_APP_API_BASE_URL: http://localhost:8080
        REACT_APP_ENV: development
    container_name: app-frontend-dev
    ports:
      - "3000:80"
    depends_on:
      - backend
    networks:
      - app-network
    restart: unless-stopped

volumes:
  postgres_dev_data:
  redis_dev_data:

networks:
  app-network:
    driver: bridge
```

#### 2. í”„ë¡œë•ì…˜ í™˜ê²½ (docker-compose.prod.yml)
```yaml
version: '3.8'

services:
  # ë°ì´í„°ë² ì´ìŠ¤
  postgres:
    image: postgres:15-alpine
    container_name: app-postgres-prod
    environment:
      POSTGRES_DB: ${DB_NAME}
      POSTGRES_USER: ${DB_USERNAME}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    volumes:
      - postgres_prod_data:/var/lib/postgresql/data
      - ./database/backup:/backup
    networks:
      - app-network
    restart: always
    deploy:
      resources:
        limits:
          memory: 1G
          cpus: '0.5'

  # Redis
  redis:
    image: redis:7-alpine
    container_name: app-redis-prod
    command: redis-server --requirepass ${REDIS_PASSWORD}
    environment:
      REDIS_PASSWORD: ${REDIS_PASSWORD}
    volumes:
      - redis_prod_data:/data
    networks:
      - app-network
    restart: always
    deploy:
      resources:
        limits:
          memory: 512M
          cpus: '0.25'

  # ë°±ì—”ë“œ
  backend:
    image: ${DOCKER_REGISTRY}/app-backend:${VERSION}
    container_name: app-backend-prod
    environment:
      SPRING_PROFILES_ACTIVE: prod
      DB_HOST: postgres
      DB_PORT: 5432
      DB_NAME: ${DB_NAME}
      DB_USERNAME: ${DB_USERNAME}
      DB_PASSWORD: ${DB_PASSWORD}
      REDIS_HOST: redis
      REDIS_PORT: 6379
      REDIS_PASSWORD: ${REDIS_PASSWORD}
    depends_on:
      - postgres
      - redis
    volumes:
      - ./logs:/app/logs
    networks:
      - app-network
    restart: always
    deploy:
      replicas: 2
      resources:
        limits:
          memory: 2G
          cpus: '1'

  # í”„ë¡ íŠ¸ì—”ë“œ
  frontend:
    image: ${DOCKER_REGISTRY}/app-frontend:${VERSION}
    container_name: app-frontend-prod
    depends_on:
      - backend
    networks:
      - app-network
    restart: always
    deploy:
      replicas: 2
      resources:
        limits:
          memory: 512M
          cpus: '0.5'

  # ë¡œë“œ ë°¸ëŸ°ì„œ (Nginx)
  nginx:
    image: nginx:alpine
    container_name: app-nginx-prod
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./nginx/ssl:/etc/nginx/ssl
      - ./logs/nginx:/var/log/nginx
    depends_on:
      - frontend
      - backend
    networks:
      - app-network
    restart: always

volumes:
  postgres_prod_data:
  redis_prod_data:

networks:
  app-network:
    driver: bridge
```

### CI/CD íŒŒì´í”„ë¼ì¸ êµ¬ì„±

#### 1. GitHub Actions ì›Œí¬í”Œë¡œìš°
```yaml
# .github/workflows/deploy.yml
name: Build and Deploy

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  DOCKER_REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Run backend tests
        run: |
          cd backend
          ./gradlew test jacocoTestReport

      - name: Run frontend tests
        run: |
          cd frontend
          npm ci
          npm run test:ci

      - name: Upload coverage reports
        uses: codecov/codecov-action@v3
        with:
          files: backend/build/reports/jacoco/test/jacocoTestReport.xml,frontend/coverage/lcov.info

  build:
    needs: test
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    outputs:
      version: ${{ steps.version.outputs.version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate version
        id: version
        run: |
          if [[ ${{ github.ref }} == 'refs/heads/main' ]]; then
            VERSION=$(date +%Y%m%d)-$(echo ${{ github.sha }} | cut -c1-7)
          else
            VERSION=$(date +%Y%m%d)-$(echo ${{ github.sha }} | cut -c1-7)-dev
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push backend image
        uses: docker/build-push-action@v5
        with:
          context: ./backend
          file: ./backend/Dockerfile
          push: true
          tags: |
            ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-backend:${{ steps.version.outputs.version }}
            ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-backend:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push frontend image
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          build-args: |
            REACT_APP_API_BASE_URL=${{ secrets.API_BASE_URL }}
            REACT_APP_ENV=production
          tags: |
            ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:${{ steps.version.outputs.version }}
            ${{ env.DOCKER_REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy-staging:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop'
    environment: staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to staging
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.STAGING_HOST }}
          username: ${{ secrets.STAGING_USER }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          script: |
            cd /opt/app
            export VERSION=${{ needs.build.outputs.version }}
            export DOCKER_REGISTRY=${{ env.DOCKER_REGISTRY }}
            export IMAGE_NAME=${{ env.IMAGE_NAME }}
            
            # í™˜ê²½ ë³€ìˆ˜ ë¡œë“œ
            source .env.staging
            
            # ìƒˆ ì´ë¯¸ì§€ í’€
            docker-compose -f docker-compose.staging.yml pull
            
            # ë¬´ì¤‘ë‹¨ ë°°í¬
            docker-compose -f docker-compose.staging.yml up -d
            
            # í—¬ìŠ¤ ì²´í¬
            for i in {1..10}; do
              if curl -f http://localhost/health; then
                echo "Health check passed"
                break
              fi
              echo "Health check failed, retrying in 10s..."
              sleep 10
            done

  deploy-production:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to production
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.PROD_HOST }}
          username: ${{ secrets.PROD_USER }}
          key: ${{ secrets.PROD_SSH_KEY }}
          script: |
            cd /opt/app
            export VERSION=${{ needs.build.outputs.version }}
            export DOCKER_REGISTRY=${{ env.DOCKER_REGISTRY }}
            export IMAGE_NAME=${{ env.IMAGE_NAME }}
            
            # í™˜ê²½ ë³€ìˆ˜ ë¡œë“œ
            source .env.production
            
            # ë°ì´í„°ë² ì´ìŠ¤ ë°±ì—…
            docker exec app-postgres-prod pg_dump -U $DB_USERNAME $DB_NAME > backup-$(date +%Y%m%d-%H%M%S).sql
            
            # ìƒˆ ì´ë¯¸ì§€ í’€
            docker-compose -f docker-compose.prod.yml pull
            
            # ë¸”ë£¨-ê·¸ë¦° ë°°í¬
            docker-compose -f docker-compose.prod.yml up -d --scale backend=4
            sleep 30
            docker-compose -f docker-compose.prod.yml up -d --scale backend=2
            
            # í—¬ìŠ¤ ì²´í¬
            for i in {1..15}; do
              if curl -f https://app.company.com/health; then
                echo "Production health check passed"
                break
              fi
              echo "Health check failed, retrying in 15s..."
              sleep 15
            done
            
            # ì˜¤ë˜ëœ ì´ë¯¸ì§€ ì •ë¦¬
            docker image prune -f

  notify:
    needs: [deploy-staging, deploy-production]
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Notify Slack
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: '#deployments'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
```

### ë°°í¬ ëª…ë ¹ì–´ ë° ìŠ¤í¬ë¦½íŠ¸

#### 1. ë¡œì»¬ ê°œë°œ í™˜ê²½ ì‹¤í–‰
```bash
# ì „ì²´ ìŠ¤íƒ ì‹¤í–‰
docker-compose -f docker-compose.dev.yml up -d

# ë¡œê·¸ í™•ì¸
docker-compose -f docker-compose.dev.yml logs -f

# íŠ¹ì • ì„œë¹„ìŠ¤ë§Œ ì¬ì‹œì‘
docker-compose -f docker-compose.dev.yml restart backend

# ê°œë°œ í™˜ê²½ ì¢…ë£Œ
docker-compose -f docker-compose.dev.yml down
```

#### 2. í”„ë¡œë•ì…˜ ë°°í¬ ìŠ¤í¬ë¦½íŠ¸
```bash
#!/bin/bash
# deploy.sh

set -e

# í™˜ê²½ ë³€ìˆ˜ ì„¤ì •
source .env.production

# ë²„ì „ ì •ë³´
VERSION=${1:-$(date +%Y%m%d)-$(git rev-parse --short HEAD)}
echo "Deploying version: $VERSION"

# ì´ë¯¸ì§€ ë¹Œë“œ
echo "Building images..."
docker build -t $DOCKER_REGISTRY/app-backend:$VERSION ./backend
docker build -t $DOCKER_REGISTRY/app-frontend:$VERSION ./frontend

# ì´ë¯¸ì§€ í‘¸ì‹œ
echo "Pushing images to registry..."
docker push $DOCKER_REGISTRY/app-backend:$VERSION
docker push $DOCKER_REGISTRY/app-frontend:$VERSION

# ë°°í¬
echo "Deploying to production..."
export VERSION=$VERSION
docker-compose -f docker-compose.prod.yml pull
docker-compose -f docker-compose.prod.yml up -d

# í—¬ìŠ¤ ì²´í¬
echo "Performing health check..."
for i in {1..10}; do
    if curl -f http://localhost/health; then
        echo "âœ… Deployment successful!"
        exit 0
    fi
    echo "â³ Waiting for application to start..."
    sleep 10
done

echo "âŒ Deployment failed - health check timeout"
exit 1
```

#### 3. ë¡¤ë°± ìŠ¤í¬ë¦½íŠ¸
```bash
#!/bin/bash
# rollback.sh

set -e

PREVIOUS_VERSION=${1:-"latest"}

echo "Rolling back to version: $PREVIOUS_VERSION"

# ì´ì „ ë²„ì „ìœ¼ë¡œ ë¡¤ë°±
export VERSION=$PREVIOUS_VERSION
docker-compose -f docker-compose.prod.yml pull
docker-compose -f docker-compose.prod.yml up -d

# í—¬ìŠ¤ ì²´í¬
for i in {1..10}; do
    if curl -f http://localhost/health; then
        echo "âœ… Rollback successful!"
        exit 0
    fi
    sleep 10
done

echo "âŒ Rollback failed"
exit 1
```

### ëª¨ë‹ˆí„°ë§ ë° ë¡œê¹…

#### 1. ë¡œê·¸ ìˆ˜ì§‘ ì„¤ì •
```yaml
# docker-compose.logging.yml
version: '3.8'

services:
  # ELK Stack for ë¡œê·¸ ìˆ˜ì§‘
  elasticsearch:
    image: elasticsearch:8.8.0
    environment:
      - discovery.type=single-node
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
    volumes:
      - elasticsearch_data:/usr/share/elasticsearch/data

  logstash:
    image: logstash:8.8.0
    volumes:
      - ./logstash/pipeline:/usr/share/logstash/pipeline
    depends_on:
      - elasticsearch

  kibana:
    image: kibana:8.8.0
    ports:
      - "5601:5601"
    depends_on:
      - elasticsearch

  # Prometheus for ë©”íŠ¸ë¦­ ìˆ˜ì§‘
  prometheus:
    image: prom/prometheus:latest
    ports:
      - "9090:9090"
    volumes:
      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml

  # Grafana for ëŒ€ì‹œë³´ë“œ
  grafana:
    image: grafana/grafana:latest
    ports:
      - "3001:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      - grafana_data:/var/lib/grafana

volumes:
  elasticsearch_data:
  grafana_data:
```

#### 2. ë°±ì—… ë° ë³µêµ¬ ì „ëµ
```bash
#!/bin/bash
# backup.sh

# ë°ì´í„°ë² ì´ìŠ¤ ë°±ì—…
docker exec app-postgres-prod pg_dump -U $DB_USERNAME $DB_NAME | gzip > "backup-$(date +%Y%m%d-%H%M%S).sql.gz"

# Redis ë°±ì—…
docker exec app-redis-prod redis-cli BGSAVE

# ë°±ì—… íŒŒì¼ S3 ì—…ë¡œë“œ (ì„ íƒì‚¬í•­)
aws s3 cp backup-*.sql.gz s3://app-backups/database/

# 7ì¼ ì´ìƒëœ ë°±ì—… íŒŒì¼ ì‚­ì œ
find ./backup -name "backup-*.sql.gz" -mtime +7 -delete

echo "âœ… Backup completed successfully"
```

### ë³´ì•ˆ ë° í™˜ê²½ ë³€ìˆ˜ ê´€ë¦¬

#### 1. í™˜ê²½ ë³€ìˆ˜ íŒŒì¼ í…œí”Œë¦¿
```bash
# .env.production.template
# ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì •
DB_HOST=postgres
DB_PORT=5432
DB_NAME=appdb_prod
DB_USERNAME=app_prod
DB_PASSWORD=<strong_password>

# Redis ì„¤ì •
REDIS_HOST=redis
REDIS_PORT=6379
REDIS_PASSWORD=<redis_password>

# Docker Registry
DOCKER_REGISTRY=ghcr.io/company
VERSION=latest

# SSL ì¸ì¦ì„œ (Let's Encrypt)
SSL_EMAIL=admin@company.com
DOMAIN=app.company.com

# ëª¨ë‹ˆí„°ë§
GRAFANA_ADMIN_PASSWORD=<grafana_password>

# JWT ì‹œí¬ë¦¿
JWT_SECRET=<jwt_secret_key>

# ì™¸ë¶€ API í‚¤
MAIL_API_KEY=<sendgrid_api_key>
SLACK_WEBHOOK_URL=<slack_webhook>
```

#### 2. Docker Secrets ì‚¬ìš© (Docker Swarm)
```yaml
# docker-compose.swarm.yml
version: '3.8'

services:
  backend:
    image: app-backend:latest
    secrets:
      - db_password
      - jwt_secret
    environment:
      DB_PASSWORD_FILE: /run/secrets/db_password
      JWT_SECRET_FILE: /run/secrets/jwt_secret

secrets:
  db_password:
    external: true
  jwt_secret:
    external: true
```

### ì„±ëŠ¥ ìµœì í™” ë° ìŠ¤ì¼€ì¼ë§

#### 1. ìˆ˜í‰ ìŠ¤ì¼€ì¼ë§ ì„¤ì •
```bash
# ë°±ì—”ë“œ ì„œë¹„ìŠ¤ ìŠ¤ì¼€ì¼ ì—…
docker-compose -f docker-compose.prod.yml up -d --scale backend=4

# ë¡œë“œ ë°¸ëŸ°ì„œ ì„¤ì • í™•ì¸
docker-compose -f docker-compose.prod.yml exec nginx nginx -t

# ì„œë¹„ìŠ¤ ìƒíƒœ í™•ì¸
docker-compose -f docker-compose.prod.yml ps
```

#### 2. ë¦¬ì†ŒìŠ¤ ì œí•œ ë° ëª¨ë‹ˆí„°ë§
```yaml
# docker-compose.ymlì—ì„œ ë¦¬ì†ŒìŠ¤ ì œí•œ
services:
  backend:
    deploy:
      resources:
        limits:
          memory: 2G
          cpus: '1.0'
        reservations:
          memory: 1G
          cpus: '0.5'
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3
```

### í™˜ê²½ë³„ ë°°í¬ ì „ëµ

#### 1. ê°œë°œ í™˜ê²½ ë°°í¬
```bash
# ê°œë°œ í™˜ê²½ ì‹œì‘
docker-compose -f docker-compose.dev.yml up -d

# ì½”ë“œ ë³€ê²½ ì‹œ í•« ë¦¬ë¡œë“œ (ê°œë°œ ì¤‘)
docker-compose -f docker-compose.dev.yml restart backend frontend

# ë¡œê·¸ ëª¨ë‹ˆí„°ë§
docker-compose -f docker-compose.dev.yml logs -f backend
```

#### 2. ìŠ¤í…Œì´ì§• í™˜ê²½ ë°°í¬
```bash
# ìŠ¤í…Œì´ì§• ë°°í¬ (ìë™í™”ëœ í…ŒìŠ¤íŠ¸ í¬í•¨)
./scripts/deploy-staging.sh

# í†µí•© í…ŒìŠ¤íŠ¸ ì‹¤í–‰
docker-compose -f docker-compose.staging.yml exec backend ./gradlew integrationTest

# E2E í…ŒìŠ¤íŠ¸ ì‹¤í–‰
docker-compose -f docker-compose.staging.yml exec frontend npm run test:e2e
```

#### 3. í”„ë¡œë•ì…˜ í™˜ê²½ ë°°í¬
```bash
# í”„ë¡œë•ì…˜ ë°°í¬ (ìŠ¹ì¸ í›„)
./scripts/deploy-production.sh v1.2.3

# í—¬ìŠ¤ ì²´í¬ ë° ëª¨ë‹ˆí„°ë§
./scripts/health-check.sh

# íŠ¸ë˜í”½ ëª¨ë‹ˆí„°ë§
docker-compose -f docker-compose.prod.yml exec nginx tail -f /var/log/nginx/access.log
```

## ë¬¸ì œ í•´ê²°

### ìì£¼ ë°œìƒí•˜ëŠ” ë¬¸ì œë“¤

#### ì˜ì¡´ì„± ì„¤ì¹˜ ë¬¸ì œ
```bash
# node_modules ì‚­ì œ í›„ ì¬ì„¤ì¹˜
rm -rf node_modules package-lock.json
npm install
```

#### í¬íŠ¸ ì¶©ëŒ ë¬¸ì œ
```bash
# í¬íŠ¸ ì‚¬ìš© í”„ë¡œì„¸ìŠ¤ í™•ì¸
lsof -i :3000
# í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ
kill -9 [PID]
```

### ë¡œê·¸ í™•ì¸
- ê°œë°œ ì„œë²„ ë¡œê·¸: í„°ë¯¸ë„ì—ì„œ í™•ì¸
- í”„ë¡œë•ì…˜ ë¡œê·¸: `logs/` ë””ë ‰í† ë¦¬ í™•ì¸

## ê¸°ì—¬ ë°©ë²•

### ì´ìŠˆ ë¦¬í¬íŒ…
1. í”„ë¡œì íŠ¸ì˜ GitHub Issuesì—ì„œ ìƒˆ ì´ìŠˆ ìƒì„±
2. ë²„ê·¸ ë¦¬í¬íŠ¸ ë˜ëŠ” ê¸°ëŠ¥ ìš”ì²­ í…œí”Œë¦¿ ì‚¬ìš©
3. ì¬í˜„ ê°€ëŠ¥í•œ ì˜ˆì œ ì½”ë“œ í¬í•¨

### ì½”ë“œ ê¸°ì—¬
1. ì €ì¥ì†Œ í¬í¬
2. ìƒˆ ë¸Œëœì¹˜ ìƒì„±
3. ì½”ë“œ ì‘ì„± ë° í…ŒìŠ¤íŠ¸
4. Pull Request ìƒì„±
5. ì½”ë“œ ë¦¬ë·° ëŒ€ì‘

### ë¬¸ì„œ ê¸°ì—¬
- ì˜¤íƒ€ ìˆ˜ì •, ë‚´ìš© ê°œì„ , ìƒˆë¡œìš´ ê°€ì´ë“œ ì¶”ê°€ ë“±
- Markdown í˜•ì‹ì„ ë”°ë¼ ì‘ì„±

## ì—°ë½ì²˜ ë° ì§€ì›

- **ê°œë°œíŒ€ ë¦¬ë”**: [íŒ€ì¥ ì´ë¦„] (ì´ë©”ì¼)
- **ì‚¬ë‚´ ê°œë°œì ì±„ë„**: [Slack/Teams ì±„ë„ëª…]
- **ê¸°ìˆ  ë¬¸ì˜**: [ê¸°ìˆ ì§€ì› ì±„ë„ ë˜ëŠ” ì´ë©”ì¼]

---

ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: 2024ë…„ 1ì›”

ì´ ë¬¸ì„œëŠ” ì§€ì†ì ìœ¼ë¡œ ì—…ë°ì´íŠ¸ë©ë‹ˆë‹¤. ì§ˆë¬¸ì´ë‚˜ ì œì•ˆì‚¬í•­ì´ ìˆìœ¼ì‹œë©´ ì–¸ì œë“  ì´ìŠˆë¥¼ ìƒì„±í•´ì£¼ì„¸ìš”!
